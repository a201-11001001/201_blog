<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Aop复盘（日志功能）</title>
    <url>/2023/10/20/Aop%E5%A4%8D%E7%9B%98%EF%BC%88%E6%97%A5%E5%BF%97%E5%8A%9F%E8%83%BD%EF%BC%89/</url>
    <content><![CDATA[<h3 id="Aop-自定义注解-AutoLog-mongoDB-实现日志存储"><a href="#Aop-自定义注解-AutoLog-mongoDB-实现日志存储" class="headerlink" title="Aop + 自定义注解(AutoLog) + mongoDB 实现日志存储"></a>Aop + 自定义注解(AutoLog) + mongoDB 实现日志存储</h3><h5 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h5><p>通过自定义注解 + CompletableFuture + mongoDB 实现异步存储日志</p>
<hr>
<ol>
<li>定义日志对象 实体类 （用来保存、查询 等操作）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 日志对象</span><br><span class="line"> * cloud api 用到的接口传输对象</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">public class LogDTO implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 8482720462943906924L;</span><br><span class="line"></span><br><span class="line">    /**内容*/</span><br><span class="line">    private String logContent;</span><br><span class="line"></span><br><span class="line">    /**日志类型(0:操作日志;1:登录日志;2:定时任务)  */</span><br><span class="line">    private Integer logType;</span><br><span class="line"></span><br><span class="line">    /**操作类型(1:添加;2:修改;3:删除;) */</span><br><span class="line">    private Integer operateType;</span><br><span class="line"></span><br><span class="line">    /**登录用户 */</span><br><span class="line">    private LoginUser loginUser;</span><br><span class="line"></span><br><span class="line">    private String id;</span><br><span class="line">    private String createBy;</span><br><span class="line">    private Date createTime;</span><br><span class="line">    private Long costTime;</span><br><span class="line">    private String ip;</span><br><span class="line"></span><br><span class="line">    /**请求参数 */</span><br><span class="line">    private String requestParam;</span><br><span class="line"></span><br><span class="line">    /**请求类型*/</span><br><span class="line">    private String requestType;</span><br><span class="line"></span><br><span class="line">    /**请求路径*/</span><br><span class="line">    private String requestUrl;</span><br><span class="line"></span><br><span class="line">    /**请求方法 */</span><br><span class="line">    private String method;</span><br><span class="line"></span><br><span class="line">    /**操作人用户名称*/</span><br><span class="line">    private String username;</span><br><span class="line"></span><br><span class="line">    /**操作人用户账户*/</span><br><span class="line">    private String userid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建 AutoLog(自定义注解)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface AutoLog &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 日志内容</span><br><span class="line">	 * </span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	String value() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 日志类型</span><br><span class="line">	 * </span><br><span class="line">	 * @return 0:操作日志;1:登录日志;2:定时任务;</span><br><span class="line">	 */</span><br><span class="line">	int logType() default CommonConstant.LOG_TYPE_2;</span><br><span class="line">	</span><br><span class="line">	/**</span><br><span class="line">	 * 操作日志类型</span><br><span class="line">	 * </span><br><span class="line">	 * @return （1查询，2添加，3修改，4删除）</span><br><span class="line">	 */</span><br><span class="line">	int operateType() default 0;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 模块类型 默认为common</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	ModuleType module() default ModuleType.COMMON;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建日志切面处理类</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 系统日志，切面处理类</span><br><span class="line"> *</span><br><span class="line"> * @Author scott</span><br><span class="line"> * @email jeecgos@163.com</span><br><span class="line"> * @Date 2018年1月14日</span><br><span class="line"> */</span><br><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class AutoLogAspect &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private MongoTemplate mongoTemplate;</span><br><span class="line">    @Pointcut(&quot;@annotation(org.jeecg.common.aspect.annotation.AutoLog)&quot;)</span><br><span class="line">    public void logPointCut() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Around(&quot;logPointCut()&quot;)</span><br><span class="line">    public Object around(ProceedingJoinPoint point) throws Throwable &#123;</span><br><span class="line">        // 使用 stopWatch 计算方法执行时间</span><br><span class="line">        StopWatch stopWatch = new StopWatch();</span><br><span class="line">        stopWatch.start();</span><br><span class="line">        //执行方法</span><br><span class="line">        Object result = point.proceed();</span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        //保存日志</span><br><span class="line">        saveSysLog(point, stopWatch.getLastTaskTimeMillis(), result);</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void saveSysLog(ProceedingJoinPoint joinPoint, long time, Object obj) &#123;</span><br><span class="line">        MethodSignature signature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        Method method = signature.getMethod();</span><br><span class="line">        Parameter[] parameters = method.getParameters();</span><br><span class="line">        String appendContent = Arrays.toString(parameters);</span><br><span class="line"></span><br><span class="line">        LogDTO dto = new LogDTO();</span><br><span class="line">        AutoLog syslog = method.getAnnotation(AutoLog.class);</span><br><span class="line">        if(syslog != null)&#123;</span><br><span class="line">            //update-begin-author:taoyan date:</span><br><span class="line">            String content = syslog.value();</span><br><span class="line">            if(syslog.module()== ModuleType.ONLINE)&#123;</span><br><span class="line">                content = getOnlineLogContent(obj, content);</span><br><span class="line">            &#125;</span><br><span class="line">            //注解上的描述,操作日志内容</span><br><span class="line">            dto.setLogType(syslog.logType());</span><br><span class="line">            // 追加操作内容方便演示</span><br><span class="line">            content=content+appendContent;</span><br><span class="line">            dto.setLogContent(content);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //请求的方法名</span><br><span class="line">        String className = joinPoint.getTarget().getClass().getName();</span><br><span class="line">        String methodName = signature.getName();</span><br><span class="line">        dto.setMethod(className + &quot;.&quot; + methodName + &quot;()&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //设置操作类型</span><br><span class="line">        if (CommonConstant.LOG_TYPE_2 == dto.getLogType()) &#123;</span><br><span class="line">            dto.setOperateType(getOperateType(methodName, syslog.operateType()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //获取request</span><br><span class="line">        HttpServletRequest request = SpringContextUtils.getHttpServletRequest();</span><br><span class="line">        //请求的参数</span><br><span class="line">        dto.setRequestParam(getReqestParams(request,joinPoint));</span><br><span class="line">        //设置IP地址</span><br><span class="line">        dto.setIp(IpUtils.getIpAddr(request));</span><br><span class="line">        //获取登录用户信息</span><br><span class="line">        LoginUser sysUser = (LoginUser) SecurityUtils.getSubject().getPrincipal();</span><br><span class="line">        if(sysUser!=null)&#123;</span><br><span class="line">            dto.setUserid(sysUser.getUsername());</span><br><span class="line">            dto.setUsername(sysUser.getRealname());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        //耗时</span><br><span class="line">        dto.setCostTime(time);</span><br><span class="line">        dto.setCreateTime(new Date());</span><br><span class="line"></span><br><span class="line">        // 使用 CompletableFuture 异步保存日志</span><br><span class="line">        CompletableFuture&lt;Void&gt; applicationLogTest = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            // mongodb 保存日志</span><br><span class="line">            mongoTemplate.save(dto,&quot;application-log-test&quot;);</span><br><span class="line">            mongoTemplate.insert(dto);</span><br><span class="line">        &#125;);</span><br><span class="line">        applicationLogTest.join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取操作类型</span><br><span class="line">     */</span><br><span class="line">    private int getOperateType(String methodName,int operateType) &#123;</span><br><span class="line">        if (operateType &gt; 0) &#123;</span><br><span class="line">            return operateType;</span><br><span class="line">        &#125;</span><br><span class="line">        //update-begin---author:wangshuai ---date:20220331  for：阿里云代码扫描规范(不允许任何魔法值出现在代码中)------------</span><br><span class="line">        return OperateTypeEnum.getTypeByMethodName(methodName);</span><br><span class="line">        //update-end---author:wangshuai ---date:20220331  for：阿里云代码扫描规范(不允许任何魔法值出现在代码中)------------</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @Description: 获取请求参数</span><br><span class="line">     * @author: scott</span><br><span class="line">     * @date: 2020/4/16 0:10</span><br><span class="line">     * @param request:  request</span><br><span class="line">     * @param joinPoint:  joinPoint</span><br><span class="line">     * @Return: java.lang.String</span><br><span class="line">     */</span><br><span class="line">    private String getReqestParams(HttpServletRequest request, JoinPoint joinPoint) &#123;</span><br><span class="line">        String httpMethod = request.getMethod();</span><br><span class="line">        String params = &quot;&quot;;</span><br><span class="line">        if (CommonConstant.HTTP_POST.equals(httpMethod) || CommonConstant.HTTP_PUT.equals(httpMethod) || CommonConstant.HTTP_PATCH.equals(httpMethod)) &#123;</span><br><span class="line">            Object[] paramsArray = joinPoint.getArgs();</span><br><span class="line">            // java.lang.IllegalStateException: It is illegal to call this method if the current request is not in asynchronous mode (i.e. isAsyncStarted() returns false)</span><br><span class="line">            //  https://my.oschina.net/mengzhang6/blog/2395893</span><br><span class="line">            Object[] arguments  = new Object[paramsArray.length];</span><br><span class="line">            for (int i = 0; i &lt; paramsArray.length; i++) &#123;</span><br><span class="line">                if (paramsArray[i] instanceof BindingResult || paramsArray[i] instanceof ServletRequest || paramsArray[i] instanceof ServletResponse || paramsArray[i] instanceof MultipartFile) &#123;</span><br><span class="line">                    //ServletRequest不能序列化，从入参里排除，否则报异常：java.lang.IllegalStateException: It is illegal to call this method if the current request is not in asynchronous mode (i.e. isAsyncStarted() returns false)</span><br><span class="line">                    //ServletResponse不能序列化 从入参里排除，否则报异常：java.lang.IllegalStateException: getOutputStream() has already been called for this response</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                arguments[i] = paramsArray[i];</span><br><span class="line">            &#125;</span><br><span class="line">            //update-begin-author:taoyan date:20200724 for:日志数据太长的直接过滤掉</span><br><span class="line">            PropertyFilter profilter = new PropertyFilter() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public boolean apply(Object o, String name, Object value) &#123;</span><br><span class="line">                    int length = 500;</span><br><span class="line">                    if(value!=null &amp;&amp; value.toString().length()&gt;length)&#123;</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            params = JSONObject.toJSONString(arguments, profilter);</span><br><span class="line">            //update-end-author:taoyan date:20200724 for:日志数据太长的直接过滤掉</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            MethodSignature signature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">            Method method = signature.getMethod();</span><br><span class="line">            // 请求的方法参数值</span><br><span class="line">            Object[] args = joinPoint.getArgs();</span><br><span class="line">            // 请求的方法参数名称</span><br><span class="line">            LocalVariableTableParameterNameDiscoverer u = new LocalVariableTableParameterNameDiscoverer();</span><br><span class="line">            String[] paramNames = u.getParameterNames(method);</span><br><span class="line">            if (args != null &amp;&amp; paramNames != null) &#123;</span><br><span class="line">                for (int i = 0; i &lt; args.length; i++) &#123;</span><br><span class="line">                    params += &quot;  &quot; + paramNames[i] + &quot;: &quot; + args[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return params;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * online日志内容拼接</span><br><span class="line">     * @param obj</span><br><span class="line">     * @param content</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private String getOnlineLogContent(Object obj, String content)&#123;</span><br><span class="line">        if (Result.class.isInstance(obj))&#123;</span><br><span class="line">            Result res = (Result)obj;</span><br><span class="line">            String msg = res.getMessage();</span><br><span class="line">            String tableName = res.getOnlTable();</span><br><span class="line">            if(oConvertUtils.isNotEmpty(tableName))&#123;</span><br><span class="line">                content+=&quot;,表名:&quot;+tableName;</span><br><span class="line">            &#125;</span><br><span class="line">            if(res.isSuccess())&#123;</span><br><span class="line">                content+= &quot;,&quot;+(oConvertUtils.isEmpty(msg)?&quot;操作成功&quot;:msg);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                content+= &quot;,&quot;+(oConvertUtils.isEmpty(msg)?&quot;操作失败&quot;:msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * online日志内容拼接</span><br><span class="line"> */</span><br><span class="line">private String getOnlineLogContent(Object obj, String content)&#123;</span><br><span class="line">    if (Result.class.isInstance(obj))&#123;</span><br><span class="line">        Result res = (Result)obj;</span><br><span class="line">        String msg = res.getMessage();</span><br><span class="line">        if(res.isSuccess())&#123;</span><br><span class="line">            content+= &quot;,&quot;+(oConvertUtils.isEmpty(msg)?&quot;操作成功&quot;:msg);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            content+= &quot;,&quot;+(oConvertUtils.isEmpty(msg)?&quot;操作失败&quot;:msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取操作类型(查询、添加、删除、更新...)</span><br><span class="line"> */</span><br><span class="line">private int getOperateType(String methodName,int operateType) &#123;</span><br><span class="line">    if (operateType &gt; 0) &#123;</span><br><span class="line">        return operateType;</span><br><span class="line">    &#125;</span><br><span class="line">    if (methodName.startsWith(&quot;list&quot;)) &#123;</span><br><span class="line">        return CommonConstant.OPERATE_TYPE_1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (methodName.startsWith(&quot;add&quot;)) &#123;</span><br><span class="line">        return CommonConstant.OPERATE_TYPE_2;</span><br><span class="line">    &#125;</span><br><span class="line">    if (methodName.startsWith(&quot;edit&quot;)) &#123;</span><br><span class="line">        return CommonConstant.OPERATE_TYPE_3;</span><br><span class="line">    &#125;</span><br><span class="line">    if (methodName.startsWith(&quot;delete&quot;)) &#123;</span><br><span class="line">        return CommonConstant.OPERATE_TYPE_4;</span><br><span class="line">    &#125;</span><br><span class="line">    if (methodName.startsWith(&quot;import&quot;)) &#123;</span><br><span class="line">        return CommonConstant.OPERATE_TYPE_5;</span><br><span class="line">    &#125;</span><br><span class="line">    if (methodName.startsWith(&quot;export&quot;)) &#123;</span><br><span class="line">        return CommonConstant.OPERATE_TYPE_6;</span><br><span class="line">    &#125;</span><br><span class="line">    return CommonConstant.OPERATE_TYPE_1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h5><p>遇到报错<br><code>Factory method &#39;mongoDatabaseFactory&#39; threw exception;</code></p>
<blockquote>
<p>解决:只需要在URI的末尾添加&#x2F;movie-api-db，就可以访问数据库集合：<br>spring.data.mongodb.uri&#x3D;mongodb+srv:&#x2F;&#x2F;<username>:<pwd>@<cluster>.mongodb.net&#x2F;movie-api-db</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#mongodb 配置</span><br><span class="line">data:</span><br><span class="line">  mongodb:</span><br><span class="line">    uri: mongodb+srv://&lt;username&gt;:&lt;pwd&gt;@&lt;cluster&gt;.mongodb.net/movie-api-db</span><br><span class="line">    database: test</span><br></pre></td></tr></table></figure>
<p>数据库记录<br><img src="https://cdn.jsdelivr.net/gh/a201-11001001/jsd_blog_staticSource@1.0.2/source/_posts/Aop%E5%A4%8D%E7%9B%98(%E6%97%A5%E5%BF%97%E5%8A%9F%E8%83%BD)/succers.png"></p>
<h5 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h5><p>[异步编程利器：CompletableFuture详解] <a href="https://zhuanlan.zhihu.com/p/622768247">https://zhuanlan.zhihu.com/p/622768247</a><br>[万字长文！用代码实例带你彻底：精通CompletableFuture的使用] <a href="https://zhuanlan.zhihu.com/p/477220493">https://zhuanlan.zhihu.com/p/477220493</a></p>
]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Aop</tag>
      </tags>
  </entry>
  <entry>
    <title>MVCC机制</title>
    <url>/2023/11/17/MVCC%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h4 id="多版本并发控制-Multi-Version-Concurrency-Control"><a href="#多版本并发控制-Multi-Version-Concurrency-Control" class="headerlink" title="多版本并发控制 (Multi-Version Concurrency Control)"></a>多版本并发控制 (Multi-Version Concurrency Control)</h4><p>MVCC 是一种并发控制机制，用于在多个并发事务同时读写数据库时保持数据的一致性和隔离性。它是通过在每个数据行上维护多个版本的数据来实现的。当一个事务要对数据库中的数据进行修改时，MVCC 会为该事务创建一个数据快照，而不是直接修改实际的数据行。</p>
<blockquote>
<p>MVCC 机制只有在 PR、PC下兼容，其他隔离界别下没有</p>
</blockquote>
<hr>
<h5 id="InnoDB-对-MVCC-的实现"><a href="#InnoDB-对-MVCC-的实现" class="headerlink" title="InnoDB 对 MVCC 的实现"></a>InnoDB 对 MVCC 的实现</h5><p>MVCC 的实现依赖于：隐藏字段、Read View、undo log。在内部实现中，InnoDB 通过数据行的 DB_TRX_ID 和 Read View 来判断数据的可见性，如不可见，则通过数据行的 DB_ROLL_PTR 找到 undo log 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 Read View 之前已经提交的修改和该事务本身做的修改</p>
<h5 id="Innodb隐藏字段"><a href="#Innodb隐藏字段" class="headerlink" title="Innodb隐藏字段"></a>Innodb隐藏字段</h5><ol>
<li><p>DB_ROW_ID<br>行标识（隐藏单调自增 ID），大小为 6 字节，如果表没有主键，InnoDB 会自动生成一个隐藏主键，因此会出现这个列。如果没有设置主键且该表没有唯一非空索引时，InnoDB 会使用该 id 来生成聚簇索引</p>
</li>
<li><p>DB_TRX_ID（最近一次提交事务的ID）：修改表数据时，都会提交事务，每个事务都有一个唯一的ID，这个字段就记录了最近一次提交事务的ID。另外，每条记录的头信息（record header）里都有一个专门的 bit（deleted_flag）来表示当前记录是否已经被删除。</p>
</li>
<li><p>DB_ROLL_PTR（上个版本的地址）：修改表数据时，旧版本的数据都会被记录到Undo Log日志中，每个版本的数据都有一个版本地址，这个字段记录的就是上个版本的地址。（回滚指针，指向该行的 undo log 。如果该行未被更新，则为空）</p>
</li>
</ol>
<h5 id="read-view"><a href="#read-view" class="headerlink" title="read view"></a>read view</h5><blockquote>
<p>在 read committed 和 read repeatable 隔离级别下，MVCC 采用read view 来实现的，它们的区别在于创建 read view 时机不同：<br>Read View 主要是用来做可见性判断，里面保存了 “当前对本事务不可见的其他活跃事务”</p>
</blockquote>
<h5 id="主要有以下字段："><a href="#主要有以下字段：" class="headerlink" title="主要有以下字段："></a>主要有以下字段：</h5><ul>
<li>m_low_limit_id：目前出现过的最大的事务 ID+1，即下一个将被分配的事务 ID。大于等于这个 ID 的数据版本均不可见</li>
<li>m_up_limit_id：活跃事务列表 m_ids 中最小的事务 ID，如果 m_ids 为空，则 m_up_limit_id 为 m_low_limit_id。小于这个 ID 的数据版本均可见</li>
<li>m_ids：Read View 创建时其他未提交的活跃事务 ID 列表。创建 Read View时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。m_ids 不包括当前事务自己和已提交的事务（正在内存中）</li>
<li>m_creator_trx_id：创建该 Read View 的事务 ID</li>
</ul>
<h5 id="事务可见性示意图"><a href="#事务可见性示意图" class="headerlink" title="事务可见性示意图"></a>事务可见性示意图</h5><p><img src="https://cdn.jsdelivr.net/gh/a201-11001001/jsd_blog_staticSource/source/_posts/MVCC%E6%9C%BA%E5%88%B6/read-view-visibility.png" alt="事务可见性示意图"></p>
<h5 id="undo-log"><a href="#undo-log" class="headerlink" title="undo-log"></a>undo-log</h5><blockquote>
<p>undo log 主要有两个作用：</p>
</blockquote>
<p>当事务回滚时用于将数据恢复到修改前的样子<br>另一个作用是 MVCC ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 undo log 读取之前的版本数据，以此实现非锁定读</p>
<h5 id="在-InnoDB-存储引擎中-undo-log-分为两种：insert-undo-log-和-update-undo-log："><a href="#在-InnoDB-存储引擎中-undo-log-分为两种：insert-undo-log-和-update-undo-log：" class="headerlink" title="在 InnoDB 存储引擎中 undo log 分为两种：insert undo log 和 update undo log："></a>在 InnoDB 存储引擎中 undo log 分为两种：insert undo log 和 update undo log：</h5><ol>
<li><p>insert undo log：指在 insert 操作中产生的 undo log。因为 insert 操作的记录只对事务本身可见，对其他事务不可见，故该 undo log 可以在事务提交后直接删除。不需要进行 purge 操作<br>insert 时的数据初始状态：<br><img src="https://cdn.jsdelivr.net/gh/a201-11001001/jsd_blog_staticSource/source/_posts/MVCC%E6%9C%BA%E5%88%B6/mvcc_1.png" alt="mvcc_1"></p>
</li>
<li><p>update undo log：update 或 delete 操作中产生的 undo log。该 undo log可能需要提供 MVCC 机制，因此不能在事务提交时就进行删除。提交时放入 undo log 链表，等待 purge线程 进行最后的删除</p>
</li>
</ol>
<h5 id="数据第一次被修改时："><a href="#数据第一次被修改时：" class="headerlink" title="数据第一次被修改时："></a>数据第一次被修改时：</h5><p><img src="https://cdn.jsdelivr.net/gh/a201-11001001/jsd_blog_staticSource/source/_posts/MVCC%E6%9C%BA%E5%88%B6/MVCC_2.png" alt="mvcc_2"></p>
<h5 id="数据第二次被修改时："><a href="#数据第二次被修改时：" class="headerlink" title="数据第二次被修改时："></a>数据第二次被修改时：</h5><p><img src="https://cdn.jsdelivr.net/gh/a201-11001001/jsd_blog_staticSource/source/_posts/MVCC%E6%9C%BA%E5%88%B6/MVCC_3.png" alt="mvcc_3"></p>
<p>不同事务或者相同事务的对同一记录行的修改，会使该记录行的 undo log 成为一条链表，链首就是最新的记录，链尾就是最早的旧记录。</p>
<h5 id="数据可见性算法"><a href="#数据可见性算法" class="headerlink" title="数据可见性算法"></a>数据可见性算法</h5><p>在 InnoDB 存储引擎中，创建一个新事务后，执行每个 select 语句前，都会创建一个快照（Read View），<strong>快照中保存了当前数据库系统中正处于活跃（没有 commit）的事务的 ID 号</strong>。其实简单的说保存的是系统中当前不应该被本事务看到的其他事务 ID 列表（即 m_ids）。当用户在这个事务中要读取某个记录行的时候，InnoDB 会将该记录行的 DB_TRX_ID 与 Read View 中的一些变量及当前事务 ID 进行比较，判断是否满足可见性条件</p>
<p>具体的比较算法如下(图源)：<br><img src="https://cdn.jsdelivr.net/gh/a201-11001001/jsd_blog_staticSource/source/_posts/MVCC%E6%9C%BA%E5%88%B6/MVCC_4.png" alt="mvcc_4"></p>
<ol>
<li><p>如果记录 DB_TRX_ID &lt; m_up_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之前就提交了，所以该记录行的值对当前事务是可见的</p>
</li>
<li><p>如果 DB_TRX_ID &gt;&#x3D; m_low_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之后才修改该行，所以该记录行的值对当前事务不可见。跳到步骤 5</p>
</li>
<li><p>m_ids 为空，则表明在当前事务创建快照之前，修改该行的事务就已经提交了，所以该记录行的值对当前事务是可见的</p>
</li>
<li><p>如果 m_up_limit_id &lt;&#x3D; DB_TRX_ID &lt; m_low_limit_id，表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照的时候可能处于“活动状态”或者“已提交状态”；所以就要对活跃事务列表 m_ids 进行查找（源码中是用的二分查找，因为是有序的）</p>
</li>
<li><p>如果在活跃事务列表 m_ids 中能找到 DB_TRX_ID，表明：① 在当前事务创建快照前，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了，但没有提交；或者 ② 在当前事务创建快照后，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了。这些情况下，这个记录行的值对当前事务都是不可见的。跳到步骤 5</p>
</li>
<li><p>在活跃事务列表中找不到，则表明“id 为 trx_id 的事务”在修改“该记录行的值”后，在“当前事务”创建快照前就已经提交了，所以记录行对当前事务可见</p>
</li>
<li><p>在该记录行的 DB_ROLL_PTR 指针所指向的 undo log 取出快照记录，用快照记录的 DB_TRX_ID 跳到步骤 1 重新开始判断，直到找到满足的快照版本或返回空</p>
</li>
</ol>
<h5 id="RC-和-RR-隔离级别下-MVCC-的差异"><a href="#RC-和-RR-隔离级别下-MVCC-的差异" class="headerlink" title="RC 和 RR 隔离级别下 MVCC 的差异"></a>RC 和 RR 隔离级别下 MVCC 的差异</h5><p>在事务隔离级别 RC 和 RR （InnoDB 存储引擎的默认事务隔离级别）下，InnoDB 存储引擎使用 MVCC（非锁定一致性读），但它们生成 Read View 的时机却不同</p>
<ul>
<li>在 RC 隔离级别下的 每次select 查询前都生成一个Read View (m_ids 列表)</li>
<li>在 RR 隔离级别下只在事务开始后 第一次select 数据前生成一个Read View（m_ids 列表）</li>
</ul>
<h5 id="MVCC-解决不可重复读问题"><a href="#MVCC-解决不可重复读问题" class="headerlink" title="MVCC 解决不可重复读问题"></a>MVCC 解决不可重复读问题</h5><p>虽然 RC 和 RR 都通过 MVCC 来读取快照数据，但由于 生成 Read View 时机不同，从而在 RR 级别下实现可重复读</p>
<p>举个例子：<br><img src="https://cdn.jsdelivr.net/gh/a201-11001001/jsd_blog_staticSource/source/_posts/MVCC%E6%9C%BA%E5%88%B6/MVCC_5.png" alt="mvcc_5"></p>
<h5 id="在-RC-下-ReadView-生成情况"><a href="#在-RC-下-ReadView-生成情况" class="headerlink" title="在 RC 下 ReadView 生成情况"></a>在 RC 下 ReadView 生成情况</h5><ol>
<li>假设时间线来到 T4 ，那么此时数据行 id &#x3D; 1 的版本链为：<br><img src="https://cdn.jsdelivr.net/gh/a201-11001001/jsd_blog_staticSource/source/_posts/MVCC%E6%9C%BA%E5%88%B6/MVCC_6.png" alt="mvcc_6"></li>
</ol>
<p>由于 RC 级别下每次查询都会生成Read View ，并且事务 101、102 并未提交，此时 103 事务生成的 Read View 中活跃的事务 m_ids 为：[101,102] ，m_low_limit_id为：104，m_up_limit_id为：101，m_creator_trx_id 为：103</p>
<ul>
<li>此时最新记录的 DB_TRX_ID 为 101，m_up_limit_id &lt;&#x3D; 101 &lt; m_low_limit_id，所以要在 m_ids 列表中查找，发现 DB_TRX_ID 存在列表中，那么这个记录不可见</li>
<li>根据 DB_ROLL_PTR 找到 undo log 中的上一版本记录，上一条记录的 DB_TRX_ID 还是 101，不可见</li>
<li>继续找上一条 DB_TRX_ID为 1，满足 1 &lt; m_up_limit_id，可见，所以事务 103 查询到数据为 name &#x3D; 菜花</li>
</ul>
<ol start="2">
<li>时间线来到 T6 ，数据的版本链为：<br><img src="https://cdn.jsdelivr.net/gh/a201-11001001/jsd_blog_staticSource/source/_posts/MVCC%E6%9C%BA%E5%88%B6/MVCC_7.png" alt="mvcc_7"></li>
</ol>
<p>因为在 RC 级别下，重新生成 Read View，这时事务 101 已经提交，102 并未提交，所以此时 Read View 中活跃的事务 m_ids：[102] ，m_low_limit_id为：104，m_up_limit_id为：102，m_creator_trx_id为：103</p>
<ul>
<li><p>此时最新记录的 DB_TRX_ID 为 102，m_up_limit_id &lt;&#x3D; 102 &lt; m_low_limit_id，所以要在 m_ids 列表中查找，发现 DB_TRX_ID 存在列表中，那么这个记录不可见</p>
</li>
<li><p>根据 DB_ROLL_PTR 找到 undo log 中的上一版本记录，上一条记录的 DB_TRX_ID 为 101，满足 101 &lt; m_up_limit_id，记录可见，所以在 T6 时间点查询到数据为 name &#x3D; 李四，与时间 T4 查询到的结果不一致，不可重复读！</p>
</li>
</ul>
<ol start="3">
<li>时间线来到 T9 ，数据的版本链为：<br><img src="https://cdn.jsdelivr.net/gh/a201-11001001/jsd_blog_staticSource/source/_posts/MVCC%E6%9C%BA%E5%88%B6/MVCC_8.png" alt="mvcc_8"></li>
</ol>
<p>重新生成 Read View， 这时事务 101 和 102 都已经提交，所以 m_ids 为空，则 m_up_limit_id &#x3D; m_low_limit_id &#x3D; 104，最新版本事务 ID 为 102，满足 102 &lt; m_low_limit_id，可见，查询结果为 name &#x3D; 赵六</p>
<blockquote>
<p>总结： 在 RC 隔离级别下，事务在每次查询开始时都会生成并设置新的 Read View，所以导致不可重复读</p>
</blockquote>
<h5 id="在-RR-下-ReadView-生成情况"><a href="#在-RR-下-ReadView-生成情况" class="headerlink" title="在 RR 下 ReadView 生成情况"></a>在 RR 下 ReadView 生成情况</h5><p>在可重复读级别下，只会在事务开始后第一次读取数据时生成一个 Read View（m_ids 列表）</p>
<ol>
<li>在 T4 情况下的版本链为：<br><img src="https://cdn.jsdelivr.net/gh/a201-11001001/jsd_blog_staticSource/source/_posts/MVCC%E6%9C%BA%E5%88%B6/MVCC_9.png" alt="mvcc_9"></li>
</ol>
<p>在当前执行 select 语句时生成一个 Read View，此时 m_ids：[101,102] ，m_low_limit_id为：104，m_up_limit_id为：101，m_creator_trx_id 为：103</p>
<p>此时和 RC 级别下一样：</p>
<ul>
<li>最新记录的 DB_TRX_ID 为 101，m_up_limit_id &lt;&#x3D; 101 &lt; m_low_limit_id，所以要在 m_ids 列表中查找，发现 DB_TRX_ID 存在列表中，那么这个记录不可见</li>
<li>根据 DB_ROLL_PTR 找到 undo log 中的上一版本记录，上一条记录的 DB_TRX_ID 还是 101，不可见</li>
<li>继续找上一条 DB_TRX_ID为 1，满足 1 &lt; m_up_limit_id，可见，所以事务 103 查询到数据为 name &#x3D; 菜花</li>
</ul>
<ol start="2">
<li>时间点 T6 情况下：<br><img src="https://cdn.jsdelivr.net/gh/a201-11001001/jsd_blog_staticSource/source/_posts/MVCC%E6%9C%BA%E5%88%B6/MVCC_10.png" alt="mvcc_10"></li>
</ol>
<p>在 RR 级别下只会生成一次Read View，所以此时依然沿用 m_ids：[101,102] ，m_low_limit_id为：104，m_up_limit_id为：101，m_creator_trx_id 为：103</p>
<ul>
<li><p>最新记录的 DB_TRX_ID 为 102，m_up_limit_id &lt;&#x3D; 102 &lt; m_low_limit_id，所以要在 m_ids 列表中查找，发现 DB_TRX_ID 存在列表中，那么这个记录不可见</p>
</li>
<li><p>根据 DB_ROLL_PTR 找到 undo log 中的上一版本记录，上一条记录的 DB_TRX_ID 为 101，不可见</p>
</li>
<li><p>继续根据 DB_ROLL_PTR 找到 undo log 中的上一版本记录，上一条记录的 DB_TRX_ID 还是 101，不可见</p>
</li>
<li><p>继续找上一条 DB_TRX_ID为 1，满足 1 &lt; m_up_limit_id，可见，所以事务 103 查询到数据为 name &#x3D; 菜花</p>
</li>
</ul>
<ol start="3">
<li>时间点 T9 情况下：<br><img src="https://cdn.jsdelivr.net/gh/a201-11001001/jsd_blog_staticSource/source/_posts/MVCC%E6%9C%BA%E5%88%B6/MVCC_11.png" alt="mvcc_11"><!--  -->
<!--  --></li>
</ol>
<p>此时情况跟 T6 完全一样，由于已经生成了 Read View，此时依然沿用 m_ids：[101,102] ，所以查询结果依然是 name &#x3D; 菜花</p>
<h4 id="MVCC➕Next-key-Lock-防止幻读"><a href="#MVCC➕Next-key-Lock-防止幻读" class="headerlink" title="MVCC➕Next-key-Lock 防止幻读"></a>MVCC➕Next-key-Lock 防止幻读</h4><hr>
<p>InnoDB存储引擎在 RR 级别下通过 MVCC和 Next-key Lock 来解决幻读问题<br>1、执行普通 select，此时会以 MVCC 快照读的方式读取数据</p>
<p>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 Read View ，并使用至事务提交。所以在生成 Read View 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”</p>
<p>2、执行 select…for update&#x2F;lock in share mode、insert、update、delete 等当前读</p>
<p>在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！InnoDB 使用 Next-key Lock 来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读</p>
]]></content>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ避免消息不丢失</title>
    <url>/2023/10/27/RabbitMQ%E9%81%BF%E5%85%8D%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1/</url>
    <content><![CDATA[<h4 id="RabbitMQ避免消息丢失"><a href="#RabbitMQ避免消息丢失" class="headerlink" title="RabbitMQ避免消息丢失"></a>RabbitMQ避免消息丢失</h4><hr>
<h5 id="RabbitMQ消息丢失的场景"><a href="#RabbitMQ消息丢失的场景" class="headerlink" title="RabbitMQ消息丢失的场景"></a>RabbitMQ消息丢失的场景</h5><p><img src="https://cdn.jsdelivr.net/gh/a201-11001001/jsd_blog_staticSource/source/_posts/RabbitMQ%E9%81%BF%E5%85%8D%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1/WX20231205-204120@2x.png" alt="RabbitMQ消息丢失的场景"></p>
<ol>
<li>生产者弄丢了数据,消息发送给 RabbitMq 的时候出现了网络波动,导致服务没有收到消息</li>
<li>RabbitMQ 没有持久化,自己把消息弄丢了</li>
<li>消费端弄丢了数据,消费端接收到数据还没来及消费出现了宕机或故障导致消息丢失</li>
</ol>
<h5 id="1、保证消息到RabbitMQ服务"><a href="#1、保证消息到RabbitMQ服务" class="headerlink" title="1、保证消息到RabbitMQ服务"></a>1、保证消息到RabbitMQ服务</h5><ul>
<li>开启事物  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 结合声明式事物</span><br><span class="line">@Transactional // 事务注解</span><br><span class="line">public void sendMessage() &#123;</span><br><span class="line">    // 开启事务</span><br><span class="line">    rabbitTemplate.setChannelTransacted(true);</span><br><span class="line">    // 发送消息</span><br><span class="line">    rabbitTemplate.convertAndSend(RabbitMQConfig.Direct_Exchange, routingKey, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用 confirm 机制<blockquote>
<p>事务机制和 confirm 机制最大的不同在于，事务机制是同步的，你提交一个事务之后会阻塞在那儿，但是 confirm 机制是异步的</p>
</blockquote>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 配置文件中开启 confirm</span><br><span class="line">spring:</span><br><span class="line">    rabbitmq:</span><br><span class="line">        publisher-confirm-type: correlated  # 开启发送方确认机制</span><br></pre></td></tr></table></figure>

  在生产者开启了confirm模式之后，每次写的消息都会分配一个唯一的id，然后如果写入了rabbitmq之中，rabbitmq会给你回传一个ack消息，告诉你这个消息发送OK了；如果rabbitmq没能处理这个消息，通过调用 setConfirmCallback 可以进行重试。而且可以结合这个机制知道自己在内存里维护每个消息的id，如果超过一定时间还没接收到这个消息的回调，那么可以进行重发。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void sendMessage() &#123;</span><br><span class="line">    // 发送消息</span><br><span class="line">    rabbitTemplate.convertAndSend(RabbitMQConfig.Direct_Exchange, routingKey, message);</span><br><span class="line">    // 设置消息确认回调方法</span><br><span class="line">    rabbitTemplate.setConfirmCallback(new RabbitTemplate.ConfirmCallback() &#123;</span><br><span class="line">        /**</span><br><span class="line">         * MQ确认回调方法</span><br><span class="line">         * @param correlationData 消息的唯一标识</span><br><span class="line">         * @param ack 消息是否成功收到</span><br><span class="line">         * @param cause 失败原因</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        public void confirm(CorrelationData correlationData, boolean ack, String cause) &#123;</span><br><span class="line">            // 记录日志</span><br><span class="line">            log.info(&quot;ConfirmCallback...correlationData[&quot;+correlationData+&quot;]==&gt;ack:[&quot;+ack+&quot;]==&gt;cause:[&quot;+cause+&quot;]&quot;);</span><br><span class="line">            if (!ack) &#123;</span><br><span class="line">                // 出错处理</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="2、避免-RabbiqMQ-自己把消息丢了"><a href="#2、避免-RabbiqMQ-自己把消息丢了" class="headerlink" title="2、避免 RabbiqMQ 自己把消息丢了"></a>2、避免 RabbiqMQ 自己把消息丢了</h5><ul>
<li><p>开启持久化 </p>
<ol>
<li>Exchange 设置持久化</li>
<li>Queue 设置持久化</li>
<li>Message持久化发送：发送消息设置发送模式deliveryMode&#x3D;2，代表持久化消息</li>
</ol>
</li>
<li><p>设置集群镜像模式</p>
<ol>
<li><p>单节点模式：最简单的情况，非集群模式，节点挂了，消息就不能用了。业务可能瘫痪，只能等待。</p>
</li>
<li><p>普通模式：消息只会存在与当前节点中，并不会同步到其他节点，当前节点宕机，有影响的业务会瘫痪，只能等待节点恢复重启可用（必须持久化消息情况下）。</p>
</li>
<li><p>镜像模式：消息会同步到其他节点上，可以设置同步的节点个数，但吞吐量会下降。属于RabbitMQ的HA方案</p>
</li>
</ol>
</li>
</ul>
<p>[集群讲的很有深度的文章]<a href="https://blog.csdn.net/weixin_43498985/article/details/122185972">https://blog.csdn.net/weixin_43498985/article/details/122185972</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/a201-11001001/jsd_blog_staticSource/source/_posts/RabbitMQ%E9%81%BF%E5%85%8D%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1/RabbitMQ%E9%95%9C%E5%83%8F%E6%A8%A1%E5%BC%8F.png" alt="RabbitMQ镜像模式"></p>
<blockquote>
<p>其中最常用的就是cluster模式（集群），它可以动态增加节点或减少，但只支持同一网段的局域网内的节点。而federation允许单台服务器上或多台服务器组成的集群之间进行消息转发和路由。federation队列类似于单向点对点连接，消息会在整个联合队列之间转发任意次，直到被消费者接收。但是此方式也有弊端，就是无法实现高可用，当其中的某一个节点宕机时就导致服务不可用，这时候就需要引入中间件Hadoop。通常使用federation来连接internet上的中间服务器，用作订阅分发消息或工作队列。shovel与federation类似，不过实现更偏向于底层，它们两者均支持部署广域网节点。下面我们介绍cluster集群模式和部署过程。</p>
</blockquote>
<p>————————————————<br>版权声明：本文为CSDN博主「一条特立独行的狗、」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_43498985/article/details/122185972">https://blog.csdn.net/weixin_43498985/article/details/122185972</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/a201-11001001/jsd_blog_staticSource/source/_posts/RabbitMQ%E9%81%BF%E5%85%8D%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1/RabbitMQ%E9%95%9C%E5%83%8F%E6%A8%A1%E5%BC%8F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="RabbitMQ镜像模式工作原理"><br>上图就是镜像集群模式的实现流程，其中有三个节点（主节点、备节点1、备节点2）和三个镜像队列queue（其中备节点上的queue是由主节点镜像生成的）。要注意的是，这里的主节点和备节点是针对某个队列而言的，并不能认为一个节点作为了所有队列的主节点，因为在整个镜像集群模式下，会存在多个节点和多个队列，这时候任何一个节点都能作为某一个队列的镜像主节点，其它节点则成了镜像备节点（例如：有A、B、C三个节点和Q1、Q2、Q3三个队列，如果A作为Q1的镜像主节点，那么B和C就作为了Q1的镜像备节点，在此基础上，如果B作为了Q2的镜像主节点，那么A和C就是Q2的镜像备节点）。</p>
<p>每一个队列都是由两部分组成的，一个是queue，用来接收消息和发布消息，另外还有一个BackingQueue，它是用来做本地消息持久化处理。客户端发送给主节点队列的消息和ack应答都将会同步到其它备节点上。</p>
<blockquote>
<p>所有关于镜像主队列（mirror_queue_master）的操作，都会通过组播GM的方式同步到其它备用节点上，这里的GM负责消息的广播，mirror_queue_slave则负责回调处理（更新本次同步内容），因此当消息发送给备用节点时，则由mirror_queue_slave来做实际处理，将消息存储在queue中，如果是持久化消息则同时存储在BackingQueue中。master上的回调则由coordinator来处理（发布本次同步内容）。在主节点中，BackingQueue的存储则是由Queue进行调用。对于生产者而言，消息发送给queue之后，接着调用mirror_queue_master进行持久化处理，之后再通过GM广播发送本次同步消息给备用节点，备用节点通过回调mirror_queue_slave同步本次消息到queue和BackingQueue；对于消费者而言，从queue中获取消息之后，消息队列会等待消费者的ack应答，ack应答收到之后删除queue和BackingQueue中的该条消息，并将本次ack内容通过GM广播发送给备用节点同步本次操作。如果slave宕机了，那对于客户端的服务提供将不会有任何影响。如果master宕机了，则其它备用节点就提升为master继续服务消息不会丢失。那这其中多个备用节点是如何选择其中一个来作为master的呢？这里通过选取出“最年长的”节点作为master，因为这个备用节点相对于其它节点而言是同步时间最长、同步状态最好的一个节点，但如果存在没有任何一个slave与master完全同步的情况，那么master中未同步的消息将会丢失。<br>————————————————<br>版权声明：本文为CSDN博主「一条特立独行的狗、」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_43498985/article/details/122185972">https://blog.csdn.net/weixin_43498985/article/details/122185972</a></p>
</blockquote>
<h5 id="GM"><a href="#GM" class="headerlink" title="GM"></a>GM</h5><p>GM模块实现的一种可靠的组播通讯协议，该协议能够保证组播消息的原子性，即保证组中活着的节点要么都收到消息要么都收不到。<br>它的实现大致为：将所有的节点形成一个循环链表，每个节点都会监控位于自己左右两边的节点，当有节点新增时，相邻的节点保证当前广播的消息会复制到新的节点上；当有节点失效时，相邻的节点会接管保证本次广播的消息会复制到下一个节点。在master节点和slave节点上的这些gm形成一个group，group（gm_group）的信息会记录在mnesia中。不同的镜像队列形成不同的group。消息从master节点对应的gm发出后，顺着链表依次传送到所有的节点，由于所有节点组成一个循环链表，master节点对应的gm最终会收到自己发送的消息，这个时候master节点就知道消息已经复制到所有的slave节点了。另外需要注意的是，每一个新节点的加入都会先清空这个节点原有数据，下图是新节点加入集群的一个简单模型：<br>————————————————<br>版权声明：本文为CSDN博主「一条特立独行的狗、」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_43498985/article/details/122185972">https://blog.csdn.net/weixin_43498985/article/details/122185972</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/a201-11001001/jsd_blog_staticSource/source/_posts/RabbitMQ%E9%81%BF%E5%85%8D%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1/RabbitMQ_GM.png" alt="GM"><br>消息的同步：<br>将新节点加入已存在的镜像队列，在默认情况下ha-sync-mode&#x3D;manual，镜像队列中的消息不会主动同步到新节点，除非显式调用同步命令。当调用同步命令后，队列开始阻塞，无法对其进行操作，直到同步完毕。</p>
<p>总结<br>镜像集群模式通过从主节点拷贝消息的方式使所有节点都能保留一份数据，一旦主节点崩溃，备节点就能完成替换从而继续对外提供服务。这解决了节点宕机带来的困扰，提高了服务稳定性，但是它并不能实现负载均衡，因为每个操作都要在所有节点做一遍，这无疑降低了系统性能。再者当消息大量入队时，集群内部的网络带宽会因此时的同步通讯被大大消耗掉，因此对于可靠性要求高、性能要求不高且消息量并不多的场景比较适用。如果对高可用和负载均衡都有要求的场景则需要结合HAProxy（实现节点间负载均衡）和keepalived（实现HAproxy的主备模式）中间件搭配使用，下面我们将对这种场景的部署进行全流程概述。</p>
<p>————————————————<br>版权声明：本文为CSDN博主「一条特立独行的狗、」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_43498985/article/details/122185972">https://blog.csdn.net/weixin_43498985/article/details/122185972</a></p>
<h5 id="3、避免消费者丢失消息"><a href="#3、避免消费者丢失消息" class="headerlink" title="3、避免消费者丢失消息"></a>3、避免消费者丢失消息</h5><p>开启事物ACK机制<br><img src="https://cdn.jsdelivr.net/gh/a201-11001001/jsd_blog_staticSource/source/_posts/RabbitMQ%E9%81%BF%E5%85%8D%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1/ACK%E6%9C%BA%E5%88%B6.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ack 模式设置为手动的</span><br><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    listener:</span><br><span class="line">      simple:</span><br><span class="line">		acknowledge-mode: manual # 手动ack模式</span><br><span class="line">        concurrency: 1 # 最少消费者数量</span><br><span class="line">        max-concurrency: 10 # 最大消费者数量</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MQConsumer &#123;</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    private DispatcherService dispatcherService;</span><br><span class="line">    </span><br><span class="line">    @RabbitListener(queues = &quot;order.queue&quot;)</span><br><span class="line">    public void messageConsumer(String orderMsg, Channel channel, @Header(AmqpHeaders.DELIVERY_TAG) long tag) throws Exception &#123;</span><br><span class="line"> </span><br><span class="line">        try &#123;</span><br><span class="line"> </span><br><span class="line">            System.out.println(&quot;消息：&quot; + orderMsg);</span><br><span class="line">            JSONObject order = JSONObject.parseObject(orderMsg);</span><br><span class="line">            String orderId = order.getString(&quot;orderId&quot;);</span><br><span class="line">            // 派单处理</span><br><span class="line">            dispatcherService.dispatch(orderId);</span><br><span class="line"></span><br><span class="line">            System.out.println(1 / 0); // 出现异常</span><br><span class="line">            // 手动确认</span><br><span class="line">            channel.basicAck(tag, false);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line"> </span><br><span class="line">            // 如果出现异常的情况下 根据实际情况重发</span><br><span class="line">            // 重发一次后，丢失</span><br><span class="line">            // 参数1：消息的tag</span><br><span class="line">            // 参数2：多条处理</span><br><span class="line">            // 参数3：重发</span><br><span class="line">                // false 不会重发，会把消息打入到死信队列</span><br><span class="line">                // true 重发，建议不使用try/catch 否则会死循环</span><br><span class="line">            </span><br><span class="line">            // 手动拒绝消息</span><br><span class="line">            channel.basicNack(tag, false, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="手动-Ack-存在的弊端"><a href="#手动-Ack-存在的弊端" class="headerlink" title="手动 Ack 存在的弊端"></a>手动 Ack 存在的弊端</h5><p>如果消费者存在Bug的话，就会导致所有的消息都抛出异常，然后队列的Unacked消息数暴涨，导致MQ响应越来越慢，然后down掉 。</p>
<p>原因:因为上面消费者抛出异常，所以MQ没有得到ack响应，注意：这些消息会堆积在Unacked消息里，不会抛弃，即使另外打开一个消费者也不会被消费，直到原来的消费者客户端断开重连时，才会变成ready，这时如果通过qos设置了prefetch，没有ack响应的话，Broker不会再分配新的消息下来，就导致了阻塞</p>
<p>解决方案: 重试机制+死信队列 </p>
<h5 id="如何保证RabbitMQ消息不重复消费"><a href="#如何保证RabbitMQ消息不重复消费" class="headerlink" title="如何保证RabbitMQ消息不重复消费"></a>如何保证RabbitMQ消息不重复消费</h5><p>消费者的业务从 MQ 队列中接收数据 &#x3D;&gt; 接着处理业务 &#x3D;&gt; 业务处理成功后，消费者给 MQ 返回 ack 进行手动确认 &#x3D;&gt; 返回回调执行结果的过程中，因为网络抖动等原因，回调数据时，MQ没有返回成功。所以MQ队列中的数据会再次发给业务项目，造成重复消费。</p>
<blockquote>
<p>解决方案:</p>
</blockquote>
<ul>
<li>消息确认机制：消费者在消费消息后向RabbitMQ服务器发送确认消息（ACK），RabbitMQ收到确认消息后才会将该消息从队列中删除，如果由于某种原因消费者未能发送确认消息，RabbitMQ会认为该消息未被正常处理，然后重新将该消息发送给其他消费者或者当前消费者进行重试。</li>
<li>幂等性处理：通过在系统设计中引入唯一标识符，使得同一个消息可以被多次接收并处理，但只有第一次处理会对系统状态产生影响。例如，消费端可以在处理完一个消息后，在数据库中记录下该消息的ID，以便之后查询是否已经处理过该消息，如果已经处理过则直接忽略该消息。</li>
</ul>
<hr>
<p>最后<br>[RabbitMQ集群部署] <a href="https://blog.csdn.net/weixin_43498985/article/details/122185972">https://blog.csdn.net/weixin_43498985/article/details/122185972</a></p>
]]></content>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis主从复制</title>
    <url>/2023/12/07/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h4 id="Redis主从复制实现原理"><a href="#Redis主从复制实现原理" class="headerlink" title="Redis主从复制实现原理"></a>Redis主从复制实现原理</h4><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。</p>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul>
<li>数据冗余(由于从节点是主节点的副本，主节点数据的备份可以在从节点上实现)</li>
<li>高可用性(通过将数据复制到多个从节点，即使主节点发生故障，从节点可替代主节点提供服务，从而保障系统的高可用性。)</li>
<li>读写分离(主节点提供写服务,从节点提供读服务,分担主节点的负载,提高系统的整体性能)</li>
</ul>
<h5 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h5><blockquote>
<ul>
<li>从服务向主服务器发送 psync 命令,主服务器收到命令后在本地生成 RDB 文件 &#x3D;&#x3D;&gt; </li>
<li>生成 RDB 文件的同时会在本地创建缓冲区(用来存储 RDB 文件存储过程写入的新的命令) &#x3D;&#x3D;&gt; </li>
<li>将RDB 文件发送到从服务器 &#x3D;&#x3D;&gt; </li>
<li>从服务器收到之后先将本地的 RDB 文件删除,然后将发送过来的 RDB 文件在本地恢复 &#x3D;&#x3D;&gt;</li>
<li>主服务器发送缓冲区的命令 &#x3D;&#x3D;&gt; </li>
<li>从服务器开始接收缓存区的命令写入本地</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/a201-11001001/jsd_blog_staticSource/source/_posts/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.png" alt="Redis主从复制"></p>
<h5 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h5><p>全量复制是 Redis 最早支持的复制方式，触发全量复制的命令是 sync 和 psync。</p>
<ul>
<li>从服务发送 psync 命令进行数据同步，由于是第一次进行复制，从节点没有复制偏移量和主节点运行 id，所以发送 psync ？-1。</li>
<li>主节点接收从节点的命令后，主节点根据 psync ? -1 解析出当前为全量复制，所以回复 +FULLRESYNC，同时也会将自身的 runid 和 offset 偏移量发送给从节点，响应为 +FULLRESYNC {runid} {offset}。</li>
<li>从节点接受主节点的响应后，会保存主节点的 runid 和偏移量</li>
<li>主节点执行 bgsave 保存 RDB 文件到本地，主节点发送 RDB 文件给从节点，从节点把接受的 RDB 文件保存在本地，并直接作为从节点的数据文件，接受完 RDB 文件后从节点打印相关日志。</li>
<li>从节点开始接受 RDB 文件到接受完成期间，主节点仍然响应读写命令，因此主节点会把这期间写命令保存在客户端的缓冲区中，当从节点加载完 RDB 文件后，主节点在把缓冲区的数据发送给从节点，已保证主从之间的数据一致性。如果主节点和从节点 RDB 文件的数据传输时间过长时，按上面分析可能会造成客户端的缓冲区溢出。默认配置为 client-output-buffer-limit slave 256MB 64MB 60。 如果 60 秒内缓冲区消耗大于 64MB 或者超过 256MB 时，主节点将直接关闭客户端连接，造成全量同步失败。</li>
<li>从节点接受完主节点传送来的全部数据后会清空自身的旧数据。</li>
<li>从节点成功加载完 RDB 文件后，如果当前节点开启了 AOF 持久化功能，它会立刻做 AOF 重写操作 (bgrewriteaof) 操作，为了保证全量复制后 AOF 持久化文件立刻可用</li>
</ul>
<h5 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h5><blockquote>
<p>部分复制主要是 Redis 针对全量复制的过高开销做出的一种优化措施</p>
</blockquote>
<ul>
<li>当主从节点之间网络出现中断时，如果超过 repl-timeout 时间，主节点会认为从节点故障并中断复制连接。</li>
<li>由于主节点没有宕机，所以他依然会响应客户端命令，但因复制连接中断命令无法发送给从节点，但主节点内部会将这段时间的命令保存在客户端缓冲区中，默认大小为 1MB。</li>
<li>当主从节点网络恢复后，从节点会再次连接上主节点。当主从节点连接恢复后，由于从节点之前保存了自身的偏移量和主节点的运行 id。因此会把它们当作 psync 参数发送给主节点，要求进行部分复制操作。</li>
<li>主节点接受从节点的 psync 命令，会先核对请求的 runid 是否和自身的的 runid 一致，如果一致，说明该从节点复制的当前主节点。然后查偏移量是否相等，如果不等则进行部分复制，如果相同则表示数据一致不需要复制</li>
<li>在进行部分复制时，主节点只需要根据偏移量将复制积压缓冲区的数据发送给从节点，保证主从复制进入正常状态</li>
</ul>
<h5 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h5><p>在命令传播阶段，除了发送写命令，主从节点还维持着心跳机制：ping 和 replconf ack。心跳机制对于主从复制的超时判断、数据安全等有作用。</p>
<p>主从节点彼此都有心跳检测机制，各自模拟成对方的客户端进行通信，通过 client list 命令查看复制客户端信息，主节点的连接状态为 flags &#x3D; M，从节点连接状态为 flags &#x3D; S。<br>主节点默认每隔 10 秒对从节点发送 ping 命令，判断从节点的存活性和连接状态，可能通过 repl-ping-slave-period 参数修改发送频率。<br>从节点在主线程中每隔 1 秒发送 replconf ack{offset} 命令，给主节点上报自身当前的偏移量。</p>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins 自动部署前后端</title>
    <url>/2024/01/04/Jenkins-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%89%8D%E5%90%8E%E7%AB%AF/</url>
    <content><![CDATA[<h3 id="Jenkins-问题及总结"><a href="#Jenkins-问题及总结" class="headerlink" title="Jenkins 问题及总结"></a>Jenkins 问题及总结</h3><blockquote>
<p>成品展示</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/a201-11001001/jsd_blog_staticSource@1.0.1/source/_posts/Jenkins-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%89%8D%E5%90%8E%E7%AB%AF/show.png"></p>
<h5 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h5><blockquote>
<p>jenkins 默认安装目录在 &#x2F;root&#x2F;.jenkins&#x2F;workspace&#x2F; 后期git 下载下来的文件回存放在这里</p>
</blockquote>
<ul>
<li>全局安装 提前在服务器安装好所需要的 jdk、git、maven、nodeJs(npm 记得切换淘宝镜像),将安装路径贴到jenkins 全局工具配置中</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/a201-11001001/jsd_blog_staticSource@1.0.1/source/_posts/Jenkins-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%89%8D%E5%90%8E%E7%AB%AF/applicationConfig.png"></p>
<ul>
<li>安装插件 git、maven 等</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/a201-11001001/jsd_blog_staticSource@1.0.1/source/_posts/Jenkins-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%89%8D%E5%90%8E%E7%AB%AF/jenkins-plugins.png"></p>
<ul>
<li>准备工作完成 开始创建maven项目</li>
</ul>
<blockquote>
<p>注意 使用 Git 需要添加凭证 按照自己的需求创建合适的</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/a201-11001001/jsd_blog_staticSource@1.0.1/source/_posts/Jenkins-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%89%8D%E5%90%8E%E7%AB%AF/config-maven.png"></p>
<ul>
<li>注意后置配置 创建shell 脚本</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/a201-11001001/jsd_blog_staticSource@1.0.1/source/_posts/Jenkins-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%89%8D%E5%90%8E%E7%AB%AF/shell.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## cp -u : 回根据是否时最新时间进行复制</span><br><span class="line">cp -u /root/.jenkins/workspace/jz-erp/jeecg-boot-module-system/target/jeecg-boot-module-system-erp-3.2.0.jar /jenkins-workspace/jz-erp </span><br><span class="line">cd /jenkins-workspace/jz-erp/</span><br><span class="line">## 创建的启动脚本</span><br><span class="line">./start.sh </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 创建start.sh 启动脚本</span><br><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">#jar名称</span><br><span class="line">JAR_PATH=/jenkins-workspace/jz-erp/jeecg-boot-module-system-erp-3.2.0.jar</span><br><span class="line"></span><br><span class="line">PID=$(pgrep -f $JAR_PATH) # 获取进程号（PID）</span><br><span class="line">if [ -z &quot;$PID&quot; ]; then</span><br><span class="line">    echo &quot;Jar包未在运行中...&quot;</span><br><span class="line">    # 后台启动Jar包</span><br><span class="line">    nohup java -jar $JAR_PATH  &gt; /jenkins-workspace/jz-erp/jz-erp.log 2&gt;&amp;1 &amp;    #启动jar包服务，并将输出写入到Java.log文件中，前面的&amp;表示且&gt;，后面的&amp;表示后台执行</span><br><span class="line">    B=`netstat -tlpn |grep java|grep :$PORT|wc -l`   #8300是jar包服务调用的端口</span><br><span class="line">    if [ -n $B ]; then   #判断jar包服务是否成功启动</span><br><span class="line">      echo &#x27;部署成功&#x27;</span><br><span class="line">    else</span><br><span class="line">      echo &#x27;部署失败&#x27;</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line">    echo &quot;Jar包已经在运行中...&quot;</span><br><span class="line">    echo &quot;kill 进程 $PID&quot;</span><br><span class="line">    kill -9 $PID</span><br><span class="line"></span><br><span class="line">    # 后台启动Jar包</span><br><span class="line">    nohup java -jar $JAR_PATH  &gt; /jenkins-workspace/jz-erp/jz-erp.log 2&gt;&amp;1 &amp;    #启动jar包服务，并将输出写入到Java.log文件中，前面的&amp;表示且&gt;</span><br><span class="line"> SSH  139.155.45.137: session closed</span><br><span class="line">按任意键重新连接tlpn |grep java|grep :$PORT|wc -l`   #8300是jar包服务调用的端口</span><br><span class="line">    if [ -n $B ]; then   #判断jar包服务是否成功启动</span><br><span class="line">      echo &quot;部署成功&quot;</span><br><span class="line">    else</span><br><span class="line">      echo &#x27;部署失败&#x27;</span><br><span class="line">    fi</span><br><span class="line">fi  </span><br></pre></td></tr></table></figure>

<p><code>chmod +x start.sh ## 给启动脚本权限 </code></p>
<ul>
<li>开始构建</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/a201-11001001/jsd_blog_staticSource@1.0.1/source/_posts/Jenkins-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%89%8D%E5%90%8E%E7%AB%AF/start-building.png"></p>
<p>查看控制台输出,遇到问题修复…等待 success 出现表示构建完成</p>
<ul>
<li>maven项目部署完成</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/a201-11001001/jsd_blog_staticSource@1.0.1/source/_posts/Jenkins-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%89%8D%E5%90%8E%E7%AB%AF/success.png"></p>
<h5 id="部署-nodeJs-前端项目"><a href="#部署-nodeJs-前端项目" class="headerlink" title="部署 nodeJs 前端项目"></a>部署 nodeJs 前端项目</h5><p>配置node安装地址、创建shell 脚本 ,其余步骤跟 maven 项目一致</p>
<p><img src="https://cdn.jsdelivr.net/gh/a201-11001001/jsd_blog_staticSource@1.0.1/source/_posts/Jenkins-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%89%8D%E5%90%8E%E7%AB%AF/config-node.png"></p>
<h5 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h5><p>[Jenkins 安装教程] <a href="https://blog.csdn.net/ApexPredator/article/details/129694442">https://blog.csdn.net/ApexPredator/article/details/129694442</a></p>
<p>[Jenkins 安装教程] <a href="https://blog.csdn.net/qq_43372633/article/details/130371782">https://blog.csdn.net/qq_43372633/article/details/130371782</a></p>
]]></content>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>mysqldump 在linux中的定时备份</title>
    <url>/2023/08/25/mysqldump-%E5%9C%A8linux%E4%B8%AD%E7%9A%84%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<h4 id="Mysql-在Linux-中的备份"><a href="#Mysql-在Linux-中的备份" class="headerlink" title="Mysql 在Linux 中的备份"></a>Mysql 在Linux 中的备份</h4><ul>
<li><p>准备环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -V</span><br><span class="line">mysql  Ver 14.14 Distrib 5.7.43, for Linux (x86_64) using  EditLine wrapper</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置MySql vim&#x2F;etc&#x2F;my.cof mysql 5.7之后需要配置文件中加入以下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">host=127.0.0.1</span><br><span class="line">user=root</span><br><span class="line">password=&#x27;jzkj@2023#$&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试备份命令 生成sql 文件</p>
<blockquote>
<p>mysql dump-u用户名-p数据库密码–default-character-set&#x3D;utf8要备份的数据库&gt;&#x2F;back&#x2F;备份路径及文件名.sq1</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">出现警告不用管 </span><br><span class="line">mysqldump: [Warning] Using a password on the command line interface can be insecure.</span><br></pre></td></tr></table></figure>
</li>
<li><p>备份后的文件内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- MySQL dump 10.13  Distrib 5.7.43, for Linux (x86_64)</span><br><span class="line">--</span><br><span class="line">-- Host: 127.0.0.1    Database: jz_lxny</span><br><span class="line">-- ------------------------------------------------------</span><br><span class="line">-- Server version       5.7.43</span><br><span class="line"></span><br><span class="line">/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;</span><br><span class="line">/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;</span><br><span class="line">/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;</span><br><span class="line">/*!40101 SET NAMES utf8 */;</span><br><span class="line">/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;</span><br><span class="line">/*!40103 SET TIME_ZONE=&#x27;+00:00&#x27; */;</span><br><span class="line">/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;</span><br><span class="line">/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;</span><br><span class="line">/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&#x27;NO_AUTO_VALUE_ON_ZERO&#x27; */;</span><br><span class="line">/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;</span><br><span class="line"></span><br><span class="line">--</span><br><span class="line">-- Table structure for table `ces_order_customer`</span><br><span class="line">-- </span><br></pre></td></tr></table></figure>
</li>
<li><p>sql 备份恢复</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 1.登录 MySQL </span><br><span class="line"></span><br><span class="line">[root@VM-0-16-centos /]# mysql -u root -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 24</span><br><span class="line">Server version: 5.7.43 MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2023, Oracle and/or its affiliates.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type &#x27;help;&#x27; or &#x27;\h&#x27; for help. Type &#x27;\c&#x27; to clear the current input statement.</span><br><span class="line"></span><br><span class="line">mysql&gt; </span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 2.切换要备份的数据库</span><br><span class="line">## 数据库已经存在情况下先切换 数据库 (第一次登录没有自定数据库默认是在 mysql 下)</span><br><span class="line">## 使用 use 命令切换数据库</span><br><span class="line"></span><br><span class="line">mysql&gt; use back_test</span><br><span class="line">Reading table information for completion of table and column names</span><br><span class="line">You can turn off this feature to get a quicker startup with -A</span><br><span class="line"></span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 3.使用 source 命令 回复备份</span><br><span class="line">source /back/要恢复的文件备份.sql</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 4.出现效果表示成功</span><br><span class="line">mysql&gt; source /back_lxny_test_001.sql</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<ul>
<li>在linx中使通过定时任务(crontab)白动备份my sq数据库<blockquote>
<p>创建mysqldump 脚本</p>
</blockquote>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">  </span><br><span class="line">#备份位置</span><br><span class="line">backup_dir=&#x27;/usr/data/backup/mysql/&#x27;</span><br><span class="line">#获取当前时间</span><br><span class="line">current_time=$(date +&#x27;%Y-%m-%d_%H%M%S&#x27;)</span><br><span class="line">#将backup_dir和时间组合起来，再加个后缀</span><br><span class="line">filepath=$backup_dir$current_time&#x27;.sql.gz&#x27;</span><br><span class="line"></span><br><span class="line">#数据库信息，配置数据库账号密码</span><br><span class="line">s_ip=&#x27;127.0.0.1&#x27;</span><br><span class="line">username=&#x27;root&#x27;</span><br><span class="line">password=&#x27;xxx&#x27;</span><br><span class="line">source_database=&#x27;xxx&#x27;</span><br><span class="line"></span><br><span class="line">echo &quot;-----------------------&quot;$(date +%F%r)&quot;操作开始--------------------------------&quot;</span><br><span class="line">echo $(date +%F%r)&quot;开始进行数据备份...&quot;</span><br><span class="line"># 2&gt;/dev/null 可以抑制警告信息</span><br><span class="line">mysqldump -h$&#123;s_ip&#125; -P3306 -u $&#123;username&#125; -p&quot;$&#123;password&#125;&quot;  $&#123;source_database&#125; table1 table2 table3 | gzip &gt; $filepath</span><br><span class="line"></span><br><span class="line">echo $(date +%F%r)&quot;完成同步...&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 测试脚本 创建脚本可执行命令</span><br><span class="line"></span><br><span class="line">chmod u+x  脚本名称.sh</span><br><span class="line"></span><br><span class="line">## 运行脚本 并解压 (gunzip)</span><br><span class="line">2924 -rw-r--r-- 1 root root 2990363 Aug 22 17:49 back_lxny_2023-08-22_174957.sql</span><br><span class="line"> 552 -rw-r--r-- 1 root root  563125 Aug 22 17:51 back_lxny_2023-08-22_175116.sql.gz</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用 crontab + mysqldump 创建定时备份任务</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 编辑当前用户定时任务 (没有crontab 可自行安装)</span><br><span class="line"></span><br><span class="line">crontab -e</span><br><span class="line"></span><br><span class="line">## 运行上述命令后，会打开一个文本编辑器，可以在其中输入要执行的命令和时间规则。格式如下：</span><br><span class="line"></span><br><span class="line">* * * * * command</span><br><span class="line"></span><br><span class="line">## 其中，五个星号分别表示分钟、小时、日、月、周几，command 表示要执行的命令或脚本文件路径。</span><br><span class="line"></span><br><span class="line">crontab -e</span><br><span class="line">*    *    *    *    *</span><br><span class="line">-    -    -    -    -</span><br><span class="line">|    |    |    |    |</span><br><span class="line">|    |    |    |    +----------星期中星期几 (0 - 6) (星期天 为0)</span><br><span class="line">|    |    |    +---------------月份 (1 - 12) </span><br><span class="line">|    |    +--------------------一个月中的第几天 (1 - 31)</span><br><span class="line">|    +-------------------------小时 (0 - 23)</span><br><span class="line">+------------------------------分钟 (0 - 59)添加定时任务(每天12:50以及23:50执行备份操作)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 例如 </span><br><span class="line"></span><br><span class="line">crontab -e</span><br><span class="line">05 18 * * *  /usr/local/mysql/mysql_lxny_back.sh</span><br><span class="line"></span><br><span class="line">[root@VM-0-16-centos back_lxny]# ll -s</span><br><span class="line">total 552</span><br><span class="line">552 -rw-r--r-- 1 root root 563126 Aug 22 18:05 back_lxny_2023-08-22_180501.sql.gz</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>保证接口数据安全</title>
    <url>/2023/09/08/%E4%BF%9D%E8%AF%81%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h4 id="Jdk-实现数据加密"><a href="#Jdk-实现数据加密" class="headerlink" title="Jdk 实现数据加密"></a>Jdk 实现数据加密</h4><blockquote>
<p>业务需求: 主系统开放接口 &#x3D;&gt; 子系统给主系统推送结算数据 &#x3D;&gt; 主系统用推送的结算数据设计报表</p>
</blockquote>
<p>对称加密（Des，Triple Des，AES）<br>采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密。常用的单向加密算法：</p>
<ul>
<li>DES（Data Encryption Standard）：数据加密标准，速度较快，适用于加密大量数据的场合；</li>
<li>3DES（Triple DES）：是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高；</li>
<li>AES（Advanced Encryption Standard）：高级加密标准，是下一代的加密算法标准，速度快，安全级别高，支持128、192、256位密钥的加密；</li>
</ul>
<blockquote>
<p>导入 bcprov 包</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;bcprov-jdk15on&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.70&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h5 id="对称加密的简单实现"><a href="#对称加密的简单实现" class="headerlink" title="对称加密的简单实现"></a>对称加密的简单实现</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String text = &quot;你好世界！！&quot;;</span><br><span class="line"></span><br><span class="line">        String key = &quot;12345678&quot;;//des必须8字节</span><br><span class="line">        // 算法/模式/填充  默认 DES/ECB/PKCS5Padding</span><br><span class="line">        String transformation = &quot;DES&quot;;</span><br><span class="line"></span><br><span class="line">        String key1 = &quot;1234567812345678&quot;;//aes必须16字节</span><br><span class="line">        String transformation1 = &quot;AES&quot;;</span><br><span class="line"></span><br><span class="line">        String key2 = &quot;123456781234567812345678&quot;;//TripleDES使用24字节的key</span><br><span class="line">        String transformation2 = &quot;TripleDes&quot;;</span><br><span class="line"></span><br><span class="line">        String extracted = extracted(text, key, transformation, true);</span><br><span class="line">        System.out.println(&quot;DES加密：&quot; + extracted);</span><br><span class="line">        String extracted1 = extracted(extracted, key, transformation, false);</span><br><span class="line">        System.out.println(&quot;解密：&quot; + extracted1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String extracted2 = extracted(text, key1, transformation1, true);</span><br><span class="line">        System.out.println(&quot;AES加密：&quot; + extracted2);</span><br><span class="line">        String extracted3 = extracted(extracted2, key1, transformation1, false);</span><br><span class="line">        System.out.println(&quot;解密：&quot; + extracted3);</span><br><span class="line"></span><br><span class="line">        String extracted4 = extracted(text, key2, transformation2, true);</span><br><span class="line">        System.out.println(&quot;Triple Des加密：&quot; + extracted4);</span><br><span class="line">        String extracted5 = extracted(extracted, key2, transformation2, false);</span><br><span class="line">        System.out.println(&quot;解密：&quot; + extracted5);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param text           明文/base64密文</span><br><span class="line">     * @param key            密钥</span><br><span class="line">     * @param transformation 转换方式</span><br><span class="line">     * @param mode           加密/解密</span><br><span class="line">     */</span><br><span class="line">    private static String extracted(String text, String key, String transformation, boolean mode)&#123;</span><br><span class="line">        Cipher cipher = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            cipher = Cipher.getInstance(transformation);</span><br><span class="line">            // key 与给定的密钥内容相关联的密钥算法的名称</span><br><span class="line">            SecretKeySpec secretKeySpec = new SecretKeySpec(key.getBytes(), transformation);</span><br><span class="line">            //Cipher 的操作模式,加密模式：ENCRYPT_MODE、 解密模式：DECRYPT_MODE、包装模式：WRAP_MODE 或 解包装：UNWRAP_MODE）</span><br><span class="line">            cipher.init(mode ? Cipher.ENCRYPT_MODE : Cipher.DECRYPT_MODE, secretKeySpec);</span><br><span class="line">            byte[] bytes = cipher.doFinal(mode ? text.getBytes(StandardCharsets.UTF_8) : Base64.decode(text));</span><br><span class="line">            return mode ? Base64.encode(bytes) : new String(bytes);</span><br><span class="line">        &#125; catch (NoSuchAlgorithmException | NoSuchPaddingException | IllegalBlockSizeException | BadPaddingException | InvalidKeyException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>DES加密：j+tPzTH7ttEeK+FrJaLY8OwmOezdN8hF<br>解密：你好世界！！<br>AES加密：&#x2F;+cq03JhyvrTIJyYvWwc2Dc&#x2F;bFUBNKelKPSANnWgsAw&#x3D;<br>解密：你好世界！！<br>Triple Des加密：j+tPzTH7ttEeK+FrJaLY8OwmOezdN8hF<br>解密：你好世界！！</p>
</blockquote>
<h5 id="非对称加密的简单实现"><a href="#非对称加密的简单实现" class="headerlink" title="非对称加密的简单实现"></a>非对称加密的简单实现</h5><blockquote>
<p>公钥加密，也叫非对称（密钥）加密（public key encryption），属于通信科技下的网络安全二级学科，指的是由对应的一对唯一性密钥（即公开密钥和私有密钥）组成的加密方法。它解决了密钥的发布和管理问题，是商业密码的核心。在公钥加密体制中，没有公开的是私钥，公开的是公钥。常用的算法：</p>
</blockquote>
<p>RSA、ElGamal、背包算法、Rabin(Rabin的加密法可以说是RSA方法的特例)、Diffie-Hellman (D-H) 密钥交换协议中的公钥加密算法、Elliptic Curve Cryptography（ECC,椭圆曲线加密算法）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class UnSymmetryTest &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        String text = &quot;===你好世界===&quot;;</span><br><span class="line">        String algorithm = &quot;RSA&quot;;</span><br><span class="line"></span><br><span class="line">        PublicKey publicKey = getPublicKey(algorithm, &quot;/Users/a201/Downloads/publicKey.txt&quot;);</span><br><span class="line">        PrivateKey privateKey = getPrivateKey(algorithm, &quot;/Users/a201/Downloads/privateKey.txt&quot;);</span><br><span class="line"></span><br><span class="line">        String s = RSAEncrypt(text, algorithm, publicKey);</span><br><span class="line">        String s1 = RSADecrypt(s, algorithm, privateKey);</span><br><span class="line"></span><br><span class="line">        System.out.println(s);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line"></span><br><span class="line">//        generateKeyFile(&quot;RSA&quot;,&quot;/Users/a201/Downloads/privateKey.txt&quot;,&quot;/Users/a201/Downloads/publicKey.txt&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取公钥,key</span><br><span class="line">     * @param algorithm  算法</span><br><span class="line">     * @param publicPath 密匙文件路径</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private static PublicKey getPublicKey(String algorithm, String publicPath) throws IOException, NoSuchAlgorithmException, Base64DecodingException, InvalidKeySpecException &#123;</span><br><span class="line">        String publicEncodeString = FileUtils.readFileToString(new File(publicPath), StandardCharsets.UTF_8);</span><br><span class="line">        //返回转换指定算法的 public/private 关键字的 KeyFactory 对象。</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(algorithm);</span><br><span class="line">        //此类表示根据 ASN.1 类型 SubjectPublicKeyInfo 进行编码的公用密钥的 ASN.1 编码</span><br><span class="line">        X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(Base64.decode(publicEncodeString));</span><br><span class="line">        return keyFactory.generatePublic(x509EncodedKeySpec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取私钥，key</span><br><span class="line">     * @param algorithm   算法</span><br><span class="line">     * @param privatePath 密匙文件路径</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private static PrivateKey getPrivateKey(String algorithm, String privatePath) throws IOException, NoSuchAlgorithmException, Base64DecodingException, InvalidKeySpecException &#123;</span><br><span class="line">        String privateEncodeString = FileUtils.readFileToString(new File(privatePath), StandardCharsets.UTF_8);</span><br><span class="line">        //返回转换指定算法的 public/private 关键字的 KeyFactory 对象。</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(algorithm);</span><br><span class="line">        //创建私钥key的规则  此类表示按照 ASN.1 类型 PrivateKeyInfo 进行编码的专用密钥的 ASN.1 编码</span><br><span class="line">        PKCS8EncodedKeySpec pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec(Base64.decode(privateEncodeString));</span><br><span class="line">        //私钥对象</span><br><span class="line">        return keyFactory.generatePrivate(pkcs8EncodedKeySpec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 加密</span><br><span class="line">     * @param text      明文</span><br><span class="line">     * @param algorithm 算法</span><br><span class="line">     * @param key       私钥/密钥</span><br><span class="line">     * @return 密文</span><br><span class="line">     */</span><br><span class="line">    private static String RSAEncrypt(String text, String algorithm, Key key) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, NoSuchProviderException &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(algorithm);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, key);</span><br><span class="line">        byte[] bytes = cipher.doFinal(text.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        return Base64.encode(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 解密</span><br><span class="line">     * @param extracted 密文</span><br><span class="line">     * @param algorithm 算法</span><br><span class="line">     * @param key       密钥/私钥</span><br><span class="line">     * @return String 明文</span><br><span class="line">     */</span><br><span class="line">    private static String RSADecrypt(String extracted, String algorithm, Key key) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, Base64DecodingException, NoSuchProviderException &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(algorithm);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, key);</span><br><span class="line">        byte[] bytes1 = cipher.doFinal(Base64.decode(extracted));</span><br><span class="line">        return new String(bytes1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成公钥和私钥文件</span><br><span class="line">     * @param algorithm   算法</span><br><span class="line">     * @param privatePath 私钥路径</span><br><span class="line">     * @param publicPath  公钥路径</span><br><span class="line">     */</span><br><span class="line">    private static void generateKeyFile(String algorithm, String privatePath, String publicPath) throws NoSuchAlgorithmException, IOException &#123;</span><br><span class="line">        //返回生成指定算法的 public/private 密钥对的 KeyPairGenerator 对象</span><br><span class="line">        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(algorithm);</span><br><span class="line">        //生成一个密钥对</span><br><span class="line">        KeyPair keyPair = keyPairGenerator.generateKeyPair();</span><br><span class="line">        //私钥</span><br><span class="line">        PrivateKey privateKey = keyPair.getPrivate();</span><br><span class="line">        //公钥</span><br><span class="line">        PublicKey publicKey = keyPair.getPublic();</span><br><span class="line"></span><br><span class="line">        byte[] privateKeyEncoded = privateKey.getEncoded();</span><br><span class="line">        byte[] publicKeyEncoded = publicKey.getEncoded();</span><br><span class="line"></span><br><span class="line">        String privateEncodeString = Base64.encode(privateKeyEncoded);</span><br><span class="line">        String publicEncodeString = Base64.encode(publicKeyEncoded);</span><br><span class="line">        //需导入commons-io</span><br><span class="line">        FileUtils.writeStringToFile(new File(privatePath), privateEncodeString, StandardCharsets.UTF_8);</span><br><span class="line">        FileUtils.writeStringToFile(new File(publicPath), publicEncodeString, StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="非对称解密的简单实现"><a href="#非对称解密的简单实现" class="headerlink" title="非对称解密的简单实现"></a>非对称解密的简单实现</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class HybridEncryptionTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 测试数据</span><br><span class="line">        String text = &quot;[&#123;\&quot;account_set_code\&quot;:\&quot;GSTHXCXGJJGYXGS\&quot;,\&quot;account_set_name\&quot;:\&quot;甘肃通汇鑫成型钢筋加工有限公司\&quot;,\&quot;amount\&quot;:-8019030.45,\&quot;audit_status\&quot;:\&quot;new\&quot;,\&quot;create_time\&quot;:1675928668000,\&quot;creator_name\&quot;:\&quot;系统管理员\&quot;,\&quot;customer\&quot;:\&quot;甘肃通汇鑫成型钢筋加工有限公司\&quot;,\&quot;customer_code\&quot;:\&quot;GSTHXCXGJJGYXGS\&quot;,\&quot;fee_code\&quot;:\&quot;HTJC\&quot;,\&quot;fee_name\&quot;:\&quot;合同价差\&quot;,\&quot;fee_no\&quot;:\&quot;CGFYD00015\&quot;,\&quot;fee_type\&quot;:\&quot;other_fee\&quot;,\&quot;invoice_type\&quot;:\&quot;增值税专用发票（0.13）\&quot;,\&quot;op_type\&quot;:\&quot;update\&quot;,\&quot;order_source\&quot;:\&quot;ERP-GSTHXCXGJJGYXGS\&quot;,\&quot;original_remark\&quot;:\&quot;\&quot;,\&quot;receipt_or_pay\&quot;:\&quot;receipt\&quot;,\&quot;settle_customer\&quot;:\&quot;甘肃通汇鑫成型钢筋加工有限公司\&quot;,\&quot;settle_customer_code\&quot;:\&quot;GSTHXCXGJJGYXGS\&quot;,\&quot;settle_mode\&quot;:\&quot;内部转账\&quot;,\&quot;tax_rate\&quot;:13.00,\&quot;time_stamp\&quot;:\&quot;1675931247605\&quot;,\&quot;unit_price\&quot;:5000&#125;]&quot;;</span><br><span class="line">        System.out.println(&quot;原始数据: &quot;+text+&#x27;\n&#x27;);</span><br><span class="line"></span><br><span class="line">        // 算法</span><br><span class="line">        String transformation = &quot;AES&quot;;</span><br><span class="line">        // 随机密钥</span><br><span class="line">        String randomKey = extracted(transformation);</span><br><span class="line">        System.out.println(&quot;AES随机key: &quot;+randomKey+&#x27;\n&#x27;);</span><br><span class="line"></span><br><span class="line">        // 使用随机 key 对数据 对称加密</span><br><span class="line">        String symmetryData = extracted(text, randomKey, transformation, true);</span><br><span class="line">        System.out.println(&quot;AES加密：&quot; + symmetryData+&#x27;\n&#x27;);</span><br><span class="line">        String extracted3 = extracted(symmetryData, randomKey, transformation, false);</span><br><span class="line">        System.out.println(&quot;AES解密：&quot; + extracted3+&#x27;\n&#x27;);</span><br><span class="line"></span><br><span class="line">        PublicKey rsa = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 公钥应提前由接收方生成给发送方</span><br><span class="line">            rsa = getPublicKey(&quot;RSA&quot;, &quot;/Users/a201/Downloads/publicKey.txt&quot;);</span><br><span class="line">        &#125; catch (IOException | NoSuchAlgorithmException | Base64DecodingException | InvalidKeySpecException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        // 对随机 key 使用非对称加密</span><br><span class="line"></span><br><span class="line">        String rsaKey = &quot;&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            rsaKey = RSAEncrypt(randomKey, &quot;RSA&quot;, rsa);</span><br><span class="line">            System.out.println(&quot;RSA加密后:&quot; + rsaKey+&#x27;\n&#x27;);</span><br><span class="line">        &#125; catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | IllegalBlockSizeException |</span><br><span class="line">                 BadPaddingException | NoSuchProviderException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        PrivateKey privateKey = null;</span><br><span class="line">        // 解密</span><br><span class="line">        // 1、使用RSA解密 key</span><br><span class="line">        try &#123;</span><br><span class="line">            privateKey = getPrivateKey(&quot;RSA&quot;, &quot;/Users/a201/Downloads/privateKey.txt&quot;);</span><br><span class="line">        &#125; catch (IOException | NoSuchAlgorithmException | Base64DecodingException | InvalidKeySpecException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 获取解密后的  randomKey</span><br><span class="line">        String unRsaKey = &quot;&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            unRsaKey = RSADecrypt(rsaKey, &quot;RSA&quot;, privateKey);</span><br><span class="line">            System.out.println(&quot;RSA解密后:&quot; + unRsaKey +&#x27;\n&#x27;);</span><br><span class="line">        &#125; catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | IllegalBlockSizeException |</span><br><span class="line">                 BadPaddingException | Base64DecodingException | NoSuchProviderException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 2、使用 解密后的 key 对对称加密数据解密</span><br><span class="line">        String originalData = extracted(symmetryData, unRsaKey, transformation, false);</span><br><span class="line">        System.out.println(&quot;AES解密后的原始数据:&quot; + originalData+&#x27;\n&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成随机的AES密钥</span><br><span class="line">     * @param transformation 加密算法</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private static String extracted(String transformation)&#123;</span><br><span class="line">        // 生成随机的AES密钥</span><br><span class="line">        KeyGenerator aesKeyGen = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            aesKeyGen = KeyGenerator.getInstance(transformation);</span><br><span class="line">        &#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        aesKeyGen.init(128);</span><br><span class="line">        SecretKey aesKey = aesKeyGen.generateKey();</span><br><span class="line">        return Base64.encode(aesKey.getEncoded());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *  对称加密</span><br><span class="line">     * @param text           明文/base64密文</span><br><span class="line">     * @param key            密钥</span><br><span class="line">     * @param transformation 转换方式</span><br><span class="line">     * @param mode           加密/解密</span><br><span class="line">     */</span><br><span class="line">    private static String extracted(String text, String key, String transformation, boolean mode)&#123;</span><br><span class="line">        Cipher cipher = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            cipher = Cipher.getInstance(transformation);</span><br><span class="line">            // key 与给定的密钥内容相关联的密钥算法的名称</span><br><span class="line">            SecretKeySpec secretKeySpec = new SecretKeySpec(key.getBytes(), transformation);</span><br><span class="line">            //Cipher 的操作模式,加密模式：ENCRYPT_MODE、 解密模式：DECRYPT_MODE、包装模式：WRAP_MODE 或 解包装：UNWRAP_MODE）</span><br><span class="line">            cipher.init(mode ? Cipher.ENCRYPT_MODE : Cipher.DECRYPT_MODE, secretKeySpec);</span><br><span class="line">            byte[] bytes = cipher.doFinal(mode ? text.getBytes(StandardCharsets.UTF_8) : Base64.decode(text));</span><br><span class="line">            return mode ? Base64.encode(bytes) : new String(bytes);</span><br><span class="line">        &#125; catch (NoSuchAlgorithmException | NoSuchPaddingException | IllegalBlockSizeException | BadPaddingException | InvalidKeyException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取公钥,key</span><br><span class="line">     * @param algorithm  算法</span><br><span class="line">     * @param publicPath 密匙文件路径</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private static PublicKey getPublicKey(String algorithm, String publicPath) throws IOException, NoSuchAlgorithmException, Base64DecodingException, InvalidKeySpecException &#123;</span><br><span class="line">        String publicEncodeString = FileUtils.readFileToString(new File(publicPath), StandardCharsets.UTF_8);</span><br><span class="line">        //返回转换指定算法的 public/private 关键字的 KeyFactory 对象。</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(algorithm);</span><br><span class="line">        //此类表示根据 ASN.1 类型 SubjectPublicKeyInfo 进行编码的公用密钥的 ASN.1 编码</span><br><span class="line">        X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(com.sun.org.apache.xml.internal.security.utils.Base64.decode(publicEncodeString));</span><br><span class="line">        return keyFactory.generatePublic(x509EncodedKeySpec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取私钥，key</span><br><span class="line">     * @param algorithm   算法</span><br><span class="line">     * @param privatePath 密匙文件路径</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private static PrivateKey getPrivateKey(String algorithm, String privatePath) throws IOException, NoSuchAlgorithmException, Base64DecodingException, InvalidKeySpecException &#123;</span><br><span class="line">        String privateEncodeString = FileUtils.readFileToString(new File(privatePath), StandardCharsets.UTF_8);</span><br><span class="line">        //返回转换指定算法的 public/private 关键字的 KeyFactory 对象。</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(algorithm);</span><br><span class="line">        //创建私钥key的规则  此类表示按照 ASN.1 类型 PrivateKeyInfo 进行编码的专用密钥的 ASN.1 编码</span><br><span class="line">        PKCS8EncodedKeySpec pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec(com.sun.org.apache.xml.internal.security.utils.Base64.decode(privateEncodeString));</span><br><span class="line">        //私钥对象</span><br><span class="line">        return keyFactory.generatePrivate(pkcs8EncodedKeySpec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 非对称加密</span><br><span class="line">     * @param text      明文</span><br><span class="line">     * @param algorithm 算法</span><br><span class="line">     * @param key       私钥/密钥</span><br><span class="line">     * @return 密文</span><br><span class="line">     */</span><br><span class="line">    private static String RSAEncrypt(String text, String algorithm, Key key) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, NoSuchProviderException &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(algorithm);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, key);</span><br><span class="line">        byte[] bytes = cipher.doFinal(text.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        return com.sun.org.apache.xml.internal.security.utils.Base64.encode(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 非对称解密</span><br><span class="line">     * @param extracted 密文</span><br><span class="line">     * @param algorithm 算法</span><br><span class="line">     * @param key       密钥/私钥</span><br><span class="line">     * @return String 明文</span><br><span class="line">     */</span><br><span class="line">    private static String RSADecrypt(String extracted, String algorithm, Key key) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, Base64DecodingException, NoSuchProviderException &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(algorithm);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, key);</span><br><span class="line">        byte[] bytes1 = cipher.doFinal(com.sun.org.apache.xml.internal.security.utils.Base64.decode(extracted));</span><br><span class="line">        return new String(bytes1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="打印的数据"><a href="#打印的数据" class="headerlink" title="打印的数据"></a>打印的数据</h5><blockquote>
<p>原始数据:   [{“account_set_code”:”GSTHXCXGJJGYXGS”,”account_set_name”:”甘肃通汇鑫成型钢筋加工有限公司”,”amount”:-8019030.45,”audit_status”:”new”,”create_time”:1675928668000,”creator_name”:”系统管理员”,”customer”:”甘肃通汇鑫成型钢筋加工有限公司”,”customer_code”:”GSTHXCXGJJGYXGS”,”fee_code”:”HTJC”,”fee_name”:”合同价差”,”fee_no”:”CGFYD00015”,”fee_type”:”other_fee”,”invoice_type”:”增值税专用发票（0.13）”,”op_type”:”update”,”order_source”:”ERP-GSTHXCXGJJGYXGS”,”original_remark”:””,”receipt_or_pay”:”receipt”,”settle_customer”:”甘肃通汇鑫成型钢筋加工有限公司”,”settle_customer_code”:”GSTHXCXGJJGYXGS”,”settle_mode”:”内部转账”,”tax_rate”:13.00,”time_stamp”:”1675931247605”,”unit_price”:5000}]</p>
</blockquote>
<blockquote>
<p>AES随机key: K3wLrOsjDKamI27s93g+Pw&#x3D;&#x3D;</p>
</blockquote>
<blockquote>
<p>AES加密：so&#x2F;QnwwVVr0pIiuZBzI24Yew&#x2F;fxhvtIZmwCCrugbFo+VqROocE2TU0OciHRlJ50BWIfa&#x2F;4spl15l7GLAxuPTgIg1jSeWC&#x2F;NlCUskh+Xl76SEzR4T0wNYiZI7a1FtFSCP5sJHsZNCiQK3jw3oM2ytIBbFzh7N3sVQdQK&#x2F;CnAiUCx0swEM+dNTyS8JFsGoighmf6JIEqtQkd3Gjqs3TbC1QODH5sXjT0Z7R&#x2F;aI6IBzzvtn0O06kAVdsntkM2TX1eNWXYeivITprZJSFJFySPQtm2ILxuRhAHwSCd0QyHW5YZcPRsJT3tz9kRGDOE5cGcPf6UV3VPQ8N1cz&#x2F;9A1PeAt86V5XrKKhw90AZ4jL8dTG4uITKtVGyA6Ecasx6NI3zs5Qg0ofY9mYEehORB1TOdtn2kbZCvvqX0gP7jy1NqCFKf&#x2F;gp4x1dKij7CM87WI+pY+gQDjZ3gU64+NZrFuyHwvlEymxuHNUwjQonkNlKg5RtqKWCqAzeWFxm8sKEyB&#x2F;xrhM+&#x2F;4IdBUBstBN0IcIOmiVl0uS51py5U9QbbDtq5QwZwGgaMGX1yPikNpSgLnVWWGdZR398rtobw0Qwo1WP5bHAjp&#x2F;MhViTZCr6JJdolvgdxBu0ymA8mrIu+hHc30mlnjDmYjsAmJMqG72xzV6Pf+gOgHbEj6xx3YsiJWJvPb3kMhsm28Nav3LjAp98E4n1im3YEI6lktKA3t&#x2F;hFB5&#x2F;QZpQECM&#x2F;do87ya0YkFtXVoUS45qMz2EZD8xjO4AtAQiWqfcTRacfVcyT9w7IZWZg6MQM5XVJs6wLoLEg&#x2F;go++XS3iJ6W6fwLU8pweMxI&#x2F;w6+uv7tXnG3R&#x2F;v2QYZOe3OC0Cglhyunm0437l0hmhLq&#x2F;6kGCgxp6GRH9vKiVBQDQUmVknUrHLMlT9WAz5DPDLxfBmOtiemCpT5hd1Qc5YXtuv2ltesX9lys9QxiwDezkaP9gr7rqK48HTUey7ThTJqEwt&#x2F;yTkoeDDMnT0dWN5nEo3f14&#x3D;</p>
</blockquote>
<blockquote>
<p>AES解密：[{“account_set_code”:”GSTHXCXGJJGYXGS”,”account_set_name”:”甘肃通汇鑫成型钢筋加工有限公司”,”amount”:-8019030.45,”audit_status”:”new”,”create_time”:1675928668000,”creator_name”:”系统管理员”,”customer”:”甘肃通汇鑫成型钢筋加工有限公司”,”customer_code”:”GSTHXCXGJJGYXGS”,”fee_code”:”HTJC”,”fee_name”:”合同价差”,”fee_no”:”CGFYD00015”,”fee_type”:”other_fee”,”invoice_type”:”增值税专用发票（0.13）”,”op_type”:”update”,”order_source”:”ERP-GSTHXCXGJJGYXGS”,”original_remark”:””,”receipt_or_pay”:”receipt”,”settle_customer”:”甘肃通汇鑫成型钢筋加工有限公司”,”settle_customer_code”:”GSTHXCXGJJGYXGS”,”settle_mode”:”内部转账”,”tax_rate”:13.00,”time_stamp”:”1675931247605”,”unit_price”:5000}]</p>
</blockquote>
<blockquote>
<p>RSA加密后:Xx+wR6dDKiSPWjmLHKQxb14Brw62V7XtJKqTA1QREm5sttwKFFqNvlkCt5lvYb4uHCTfkxVhn89R<br>iLiQORnQgkDNTAZLCgMsiv+cLhQrNLp05mBvWGF&#x2F;CdMeFsomlCDrxaqPsdV6HKLYM4Meyl5K02mW<br>QTBWnHL7txsff5rdr+BgfxOz+i6VsFGhAcWsD70LAtNIjRHYOT+AKSCNTEcp9rLhcqBYfemwWCgd<br>bE0fCqje2PYAg&#x2F;BTAuzhSPNbLCTT9KlTFTNO0T9dI+v1kSMYK5vs0MnEqx&#x2F;akqbweEl6jeMIEWcK<br>2vMs7z9J6N&#x2F;TyyWPlb4yFnsss9f6HtWgveyUEA&#x3D;&#x3D;</p>
</blockquote>
<blockquote>
<p>RSA解密后:K3wLrOsjDKamI27s93g+Pw&#x3D;&#x3D;</p>
</blockquote>
<blockquote>
<p>AES解密后的原始数据:[{“account_set_code”:”GSTHXCXGJJGYXGS”,”account_set_name”:”甘肃通汇鑫成型钢筋加工有限公司”,”amount”:-8019030.45,”audit_status”:”new”,”create_time”:1675928668000,”creator_name”:”系统管理员”,”customer”:”甘肃通汇鑫成型钢筋加工有限公司”,”customer_code”:”GSTHXCXGJJGYXGS”,”fee_code”:”HTJC”,”fee_name”:”合同价差”,”fee_no”:”CGFYD00015”,”fee_type”:”other_fee”,”invoice_type”:”增值税专用发票（0.13）”,”op_type”:”update”,”order_source”:”ERP-GSTHXCXGJJGYXGS”,”original_remark”:””,”receipt_or_pay”:”receipt”,”settle_customer”:”甘肃通汇鑫成型钢筋加工有限公司”,”settle_customer_code”:”GSTHXCXGJJGYXGS”,”settle_mode”:”内部转账”,”tax_rate”:13.00,”time_stamp”:”1675931247605”,”unit_price”:5000}]</p>
</blockquote>
<hr>
<h5 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h5><p>[怎么设计大文件、大数据场景下的传输加密方案] <a href="https://www.cnblogs.com/xiaoxi-jinchen/p/17167910.html">https://www.cnblogs.com/xiaoxi-jinchen/p/17167910.html</a></p>
<p>[保证接口数据安全的10种方式] <a href="https://juejin.cn/post/7116520783534522399">https://juejin.cn/post/7116520783534522399</a></p>
]]></content>
      <tags>
        <tag>数据加密</tag>
        <tag>方案设计</tag>
      </tags>
  </entry>
  <entry>
    <title>EasyExcel十万级数据异步导入导出-导入</title>
    <url>/2024/02/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0-EasyExcel%E5%8D%81%E4%B8%87%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BC%82%E6%AD%A5%E5%AF%BC%E5%87%BA/</url>
    <content><![CDATA[<blockquote>
<p>实现思路 :<br> 1、mybatis-Plus 分页查询<br> 2、线程池 + countDownLatch 做异步处理<br> 3、easyExcel 多 sheet 页写入数据</p>
</blockquote>
<p> <code>1、MybatisPlus查询导出数据的总数量,创建需要的 sheet 页,创建固定的线程池,使用 总数量/sheet页(Match 做向上取整) 的出个 sheet 页面的数量,在for循环中使用线程池对数据库做分页查询期间使用 countDownLatch 来协调多个线程之间的同步,确保每个线程都完成任务,最后将数据存放到一个 map 中,对 map 循环使用EasyExcel做多个 sheet 页的写入,最后关闭写入流</code></p>
<h4 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## easyExcel</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;easyexcel&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.2.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">## lombok</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.18.24&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>


<h4 id="异步导出"><a href="#异步导出" class="headerlink" title="异步导出"></a>异步导出</h4><p>controller 层</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;import&quot;)</span><br><span class="line">   public void importExcel(MultipartFile file) throws IOException &#123;</span><br><span class="line">       importService.importExcelAsync(file);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>service 层</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class ExportService &#123;</span><br><span class="line">    public static final String CONTENT_TYPE = &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 异步导出</span><br><span class="line">     * @param response</span><br><span class="line">     * @throws IOException</span><br><span class="line">     * @throws InterruptedException</span><br><span class="line">     */</span><br><span class="line">    public void exportExcel4(HttpServletResponse response) throws IOException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        setExportHeader(response);</span><br><span class="line"></span><br><span class="line">        // 查询整张表 要导出的总数据量</span><br><span class="line"></span><br><span class="line">        int count = csFeeDetailMapper.selectCount(null).intValue();</span><br><span class="line"></span><br><span class="line">        // 要创建的sheet页数</span><br><span class="line">        int pages = 20;</span><br><span class="line">        Double size = Math.ceil((double) count / pages);</span><br><span class="line"></span><br><span class="line">        // 创建线程池</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(pages);</span><br><span class="line">        // 创建计时器</span><br><span class="line">        CountDownLatch countDownLatch = new CountDownLatch(pages);</span><br><span class="line"></span><br><span class="line">        // 存放数据的 Map&lt;工作表名称后缀,每张sheet页的数据&gt;</span><br><span class="line">        Map&lt;Integer, Page&lt;CsFeeDetail&gt;&gt; pageMap = new HashMap&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; pages; i++) &#123;</span><br><span class="line">            int finalI = i;</span><br><span class="line">            executorService.submit(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    Page&lt;CsFeeDetail&gt; page = new Page&lt;&gt;();</span><br><span class="line">                    // 分页查询数据</span><br><span class="line">                    page.setCurrent(finalI + 1);</span><br><span class="line">                    page.setSize(size.longValue());</span><br><span class="line">                    Page&lt;CsFeeDetail&gt; selectPage = csFeeDetailMapper.selectPage(page, null);</span><br><span class="line"></span><br><span class="line">                    pageMap.put(finalI, selectPage);</span><br><span class="line">                    // 计时器-1 代表一个线程结束</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 等待计时器为0 及所有线程完成任务</span><br><span class="line">        countDownLatch.await();</span><br><span class="line"></span><br><span class="line">        // 写入数据</span><br><span class="line">        try (ExcelWriter excelWriter = EasyExcel.write(response.getOutputStream(), CsFeeDetail.class).build()) &#123;</span><br><span class="line">            for (Map.Entry&lt;Integer, Page&lt;CsFeeDetail&gt;&gt; entry : pageMap.entrySet()) &#123;</span><br><span class="line">                Integer num = entry.getKey();</span><br><span class="line">                Page&lt;CsFeeDetail&gt; salariesPage = entry.getValue();</span><br><span class="line">                // 创建sheet页</span><br><span class="line">                WriteSheet writeSheet = EasyExcel.writerSheet(num, &quot;模板&quot; + num).build();</span><br><span class="line">                excelWriter.write(salariesPage.getRecords(), writeSheet);</span><br><span class="line">            &#125;</span><br><span class="line">//            excelWriter.finish();finish</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // easyexcel不支持不同的sheet页并发插入</span><br><span class="line">        // https://github.com/alibaba/easyexcel/issues/1040</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 以文件附件的形式下载</span><br><span class="line">     * @param response</span><br><span class="line">     */</span><br><span class="line">    private static void setExportHeader(HttpServletResponse response) &#123;</span><br><span class="line">        response.setContentType(CONTENT_TYPE);</span><br><span class="line">        response.setCharacterEncoding(StandardCharsets.UTF_8.name());</span><br><span class="line">        response.setHeader(&quot;Content-disposition&quot;, &quot;attachment;filename*=utf-8&#x27;&#x27;&quot; + &quot;zhouyu.xlsx&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>mapper 层、dao层 省略…</p>
<h5 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h5><ul>
<li>日志记录<br><img src="https://cdn.jsdelivr.net/gh/a201-11001001/jsd_blog_staticSource@1.0.5/source/_posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0-EasyExcel%E5%8D%81%E4%B8%87%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BC%82%E6%AD%A5%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/%E5%BC%82%E6%AD%A5%E5%AF%BC%E5%87%BAexcel.png" alt="下载文件"><br><img src="https://cdn.jsdelivr.net/gh/a201-11001001/jsd_blog_staticSource@1.0.5/source/_posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0-EasyExcel%E5%8D%81%E4%B8%87%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BC%82%E6%AD%A5%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/%E5%BC%82%E6%AD%A5%E5%AF%BC%E5%87%BAsql.png" alt="数据库数据"></li>
</ul>
<hr>
<h4 id="异步导入"><a href="#异步导入" class="headerlink" title="异步导入"></a>异步导入</h4><blockquote>
<p>实现思路:<br>1、多线程读去sheet页<br>2、invoke + doAfterAllAnalysed + ThreadLocal + 线程池 处理数据<br>3、myabtis-Plus 批量插入</p>
</blockquote>
<p><code>1、获取对应的 sheet 个数,每个线程读一个 sheet</code><br><code>2、实现 ReadListener 接口 创建 线程池 和 ThreadLocal</code><br><code>3、重写 invoke 和 doAfterAllAnalysed 方法 转换对象 利用线程池+ThreadLocal + mybatis-Plus 批量存储</code></p>
<p>controller 层</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;myImport&quot;)</span><br><span class="line">    public void myImportExcel(MultipartFile file) throws IOException &#123;</span><br><span class="line">        importService.myImportExcelAsync(file);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>实现 ReadListener 接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class CsFeeDetailListener extends ServiceImpl&lt;CsFeeDetailMapper, CsFeeDetail&gt; implements ReadListener&lt;CsFeeDetail&gt;, IService&lt;CsFeeDetail&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // 日志</span><br><span class="line">    private static final Log logger = LogFactory.getLog(CsFeeDetailListener.class);</span><br><span class="line">    // 线程池</span><br><span class="line">    private ExecutorService executorService = Executors.newFixedThreadPool(20);</span><br><span class="line">    // 多线程执行,对数据做隔离</span><br><span class="line">    private ThreadLocal&lt;ArrayList&lt;CsFeeDetail&gt;&gt; CsFeeDetailList = ThreadLocal.withInitial(ArrayList::new);</span><br><span class="line">    // 插入记录</span><br><span class="line">    private static AtomicInteger count = new AtomicInteger(1);</span><br><span class="line">    // 批量存储数据个数</span><br><span class="line">    private static final int batchSize = 1000;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private CsFeeDetailListener CsFeeDetailListener;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(rollbackFor = Exception.class)</span><br><span class="line">    public void invoke(CsFeeDetail data, AnalysisContext context) &#123;</span><br><span class="line">        CsFeeDetailList.get().add(data);</span><br><span class="line">        if (CsFeeDetailList.get().size() &gt;= batchSize) &#123;</span><br><span class="line">//            saveData();</span><br><span class="line">            asyncSaveData();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void saveOne(CsFeeDetail data)&#123;</span><br><span class="line">        save(data);</span><br><span class="line">        logger.info(&quot;第&quot; + count.getAndAdd(1) + &quot;次插入1条数据&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void saveData() &#123;</span><br><span class="line">        if (!CsFeeDetailList.get().isEmpty()) &#123;</span><br><span class="line">            saveBatch(CsFeeDetailList.get(), CsFeeDetailList.get().size());</span><br><span class="line">            logger.info(&quot;全部数据&quot;+&quot;第&quot; + count.getAndAdd(1) + &quot;次插入&quot; + CsFeeDetailList.get().size() + &quot;条数据&quot;);</span><br><span class="line">            CsFeeDetailList.get().clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void asyncSaveData() &#123;</span><br><span class="line">        if (!CsFeeDetailList.get().isEmpty()) &#123;</span><br><span class="line">            ArrayList&lt;CsFeeDetail&gt; CsFeeDetail = (ArrayList&lt;CsFeeDetail&gt;) CsFeeDetailList.get().clone();</span><br><span class="line">            executorService.execute(new SaveTask(CsFeeDetail, CsFeeDetailListener));</span><br><span class="line">            CsFeeDetailList.get().clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(rollbackFor = Exception.class)</span><br><span class="line">    public void doAfterAllAnalysed(AnalysisContext context) &#123;</span><br><span class="line">        logger.info(&quot;一个Sheet全部处理完&quot;);</span><br><span class="line">//        if (CsFeeDetailList.get().size() &gt;= batchSize) &#123;</span><br><span class="line">            saveData();</span><br><span class="line">//        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class SaveTask implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        private List&lt;CsFeeDetail&gt; CsFeeDetailList;</span><br><span class="line">        private CsFeeDetailListener CsFeeDetailListener;</span><br><span class="line"></span><br><span class="line">        public SaveTask(List&lt;CsFeeDetail&gt; CsFeeDetailList, CsFeeDetailListener CsFeeDetailListener) &#123;</span><br><span class="line">            this.CsFeeDetailList = CsFeeDetailList;</span><br><span class="line">            this.CsFeeDetailListener = CsFeeDetailListener;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            CsFeeDetailListener.saveBatch(CsFeeDetailList);</span><br><span class="line">            logger.info(&quot;第&quot; + count.getAndAdd(1) + &quot;次插入&quot; + CsFeeDetailList.size() + &quot;条数据&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="测试数据-1"><a href="#测试数据-1" class="headerlink" title="测试数据"></a>测试数据</h5><p><img src="https://cdn.jsdelivr.net/gh/a201-11001001/jsd_blog_staticSource@1.0.5/source/_posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0-EasyExcel%E5%8D%81%E4%B8%87%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BC%82%E6%AD%A5%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/import_async_log.png" alt="导入日志"><br><img src="https://cdn.jsdelivr.net/gh/a201-11001001/jsd_blog_staticSource@1.0.5/source/_posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0-EasyExcel%E5%8D%81%E4%B8%87%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BC%82%E6%AD%A5%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/postman-test.png" alt="postman测试数据"><br><img src="https://cdn.jsdelivr.net/gh/a201-11001001/jsd_blog_staticSource@1.0.5/source/_posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0-EasyExcel%E5%8D%81%E4%B8%87%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BC%82%E6%AD%A5%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/sql_data.png" alt="数据库数据"><br><img src="https://cdn.jsdelivr.net/gh/a201-11001001/jsd_blog_staticSource@1.0.5/source/_posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0-EasyExcel%E5%8D%81%E4%B8%87%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BC%82%E6%AD%A5%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/sql_test.png" alt="数据库数据"></p>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>[CountDownLatch 的理解和用法] <a href="https://www.cnblogs.com/Lee_xy_z/p/10470181.html">https://www.cnblogs.com/Lee_xy_z/p/10470181.html</a><br>[EasyExcel官网] <a href="https://easyexcel.opensource.alibaba.com/docs/current/quickstart/read#excel%E7%A4%BA%E4%BE%8B-1">https://easyexcel.opensource.alibaba.com/docs/current/quickstart/read#excel%E7%A4%BA%E4%BE%8B-1</a><br>[EasyExcel解析指定的Sheet] <a href="https://blog.51cto.com/dengshuangfu/5092722">https://blog.51cto.com/dengshuangfu/5092722</a></p>
]]></content>
      <tags>
        <tag>多线程学习</tag>
      </tags>
  </entry>
  <entry>
    <title>序列化优雅实现字典翻译</title>
    <url>/2023/09/22/%E5%BA%8F%E5%88%97%E5%8C%96%E4%BC%98%E9%9B%85%E5%AE%9E%E7%8E%B0%E5%AD%97%E5%85%B8%E7%BF%BB%E8%AF%91/</url>
    <content><![CDATA[<h4 id="序列化优雅实现字典翻译"><a href="#序列化优雅实现字典翻译" class="headerlink" title="序列化优雅实现字典翻译"></a>序列化优雅实现字典翻译</h4><blockquote>
<p>思路：<br>创建自定义注解@My Dic t,通过ContextS e rizal e来解决List、Page类型的字典翻译实现ContextualSerializer接口可以方便的获取注解字段及注解的参数方便序列化的时候拿到想要的参数</p>
</blockquote>
<ol>
<li>自定义一个注解 @MyDict<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Target(&#123;ElementType.FIELD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@JacksonAnnotationsInside</span><br><span class="line">// 自定义序列化 根据提供的序列化类里面的重写方法实现自定义序列化</span><br><span class="line">@JsonSerialize(using = DictSerializer.class)</span><br><span class="line">public @interface MyDict &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 方法描述:  数据code</span><br><span class="line">     */</span><br><span class="line">    String dicCode();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 方法描述:  数据Text</span><br><span class="line">     */</span><br><span class="line">    String dicText() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 方法描述: 数据字典表</span><br><span class="line">     */</span><br><span class="line">    String dictTable() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><p>(重点:实现Contextual Serialize r接来便捷的获取到自定义注解的参数，方便后续的字典值转换)使用了Guava Cache的缓存https:&#x2F;<a href="http://www.bael/">www.bael</a> dung.com&#x2F;guava-cache</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">public class DictSerializer extends StdSerializer&lt;Object&gt; implements ContextualSerializer &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查询mapper 用来对对字典的查询</span><br><span class="line">     */</span><br><span class="line">    private static SysDictMapper sysDictMapper;</span><br><span class="line">    @Autowired</span><br><span class="line">    public void setUserServer(SysDictMapper sysDictMapper) &#123;</span><br><span class="line">        DictSerializer.sysDictMapper = sysDictMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 字典参数</span><br><span class="line">     */</span><br><span class="line">    @Getter</span><br><span class="line">    @Setter</span><br><span class="line">    private transient String dictTable;</span><br><span class="line">    @Getter</span><br><span class="line">    @Setter</span><br><span class="line">    private transient String dictCode;</span><br><span class="line">    @Getter</span><br><span class="line">    @Setter</span><br><span class="line">    private transient String dictText;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 字典翻译文本后缀</span><br><span class="line">     */</span><br><span class="line">    public static final String DICT_TEXT_SUFFIX = &quot;_dictText&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    protected DictSerializer() &#123;</span><br><span class="line">        super(Object.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public JsonSerializer&lt;?&gt; createContextual(SerializerProvider serializerProvider, BeanProperty beanProperty) throws JsonMappingException &#123;</span><br><span class="line">        MyDict myDict = beanProperty.getAnnotation(MyDict.class);</span><br><span class="line">        return createContextual(myDict.dictTable(), myDict.dicCode(), myDict.dicText());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private JsonSerializer&lt;?&gt; createContextual(String dictTable, String dicCode, String dictText) &#123;</span><br><span class="line">        DictSerializer serializer = new DictSerializer();</span><br><span class="line">        serializer.setDictTable(dictTable);</span><br><span class="line">        serializer.setDictCode(dicCode);</span><br><span class="line">        serializer.setDictText(dictText);</span><br><span class="line">        return serializer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void serialize(Object value, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 考虑到存在字典表，用表名做一个简单的隔离</span><br><span class="line">            Map&lt;String, String&gt; cachMap = DICTIONARY_CACHE.get(getDictTable());</span><br><span class="line"></span><br><span class="line">            // 先查缓存 没有就查数据库存到缓存中，后续从缓存中读取</span><br><span class="line">            if (MapUtils.isEmpty(cachMap)) &#123;</span><br><span class="line">                Map&lt;String, String&gt; textMap = translateDict(getDictTable(), getDictText(), getDictCode());</span><br><span class="line">                DICTIONARY_CACHE.put(getDictTable(), textMap);</span><br><span class="line">                cachMap.putAll(textMap);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 添加 字典翻译字段</span><br><span class="line">            String label = cachMap.get(value.toString());</span><br><span class="line">            jsonGenerator.writeObject(value);</span><br><span class="line">            // 在需要转换的字段上添加@Dict注解，注明需要引用的code，后端会在返回值中增加filedName_dictText的key，前端只需要取对应的 filedName_dictText 就可以直接使用</span><br><span class="line">            jsonGenerator.writeFieldName(jsonGenerator.getOutputContext().getCurrentName() + DICT_TEXT_SUFFIX);</span><br><span class="line">            jsonGenerator.writeObject(label);</span><br><span class="line"></span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            log.error(&quot;字典转换异常:&quot;,e.getMessage());</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 使用谷歌Guava 做本地缓存</span><br><span class="line">     */</span><br><span class="line">    public static final LoadingCache&lt;String, Map&lt;String, String&gt;&gt; DICTIONARY_CACHE = CacheBuilder.newBuilder()</span><br><span class="line">            .maximumSize(1000)</span><br><span class="line">            .expireAfterWrite(30, TimeUnit.SECONDS)</span><br><span class="line">            .expireAfterAccess(10, TimeUnit.SECONDS)</span><br><span class="line">            .build(new CacheLoader&lt;String, Map&lt;String, String&gt;&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public Map&lt;String, String&gt; load(String key) &#123;</span><br><span class="line">                    Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">                    return map;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 翻译字典 使用 sql 查询数据表的方式获取text</span><br><span class="line">     */</span><br><span class="line">    public Map&lt;String, String&gt; translateDict(String table, String text, String code) &#123;</span><br><span class="line">        // 通过拼接sql 查询 字典值</span><br><span class="line">        List&lt;DictModel&gt; dictModels = null;</span><br><span class="line">        if (StringUtils.isEmpty(getDictTable()))&#123;</span><br><span class="line">            dictModels = sysDictMapper.queryEnableDictItemsByCode(code);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            dictModels = sysDictMapper.queryTableDictItemsByCode(table, text, code);</span><br><span class="line">        &#125;</span><br><span class="line">        // 将 list 转换为 map 方便后续的字典获取</span><br><span class="line">        return dictModels.stream().collect(Collectors.toMap(DictModel::getValue, DictModel::getText, (value1, value2) -&gt; value1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 mapper</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   /**</span><br><span class="line"> * 查询有效的数据字典项</span><br><span class="line"> * @param code</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">List&lt;DictModel&gt; queryEnableDictItemsByCode(@Param(&quot;code&quot;) String code);</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line"> * 查询数据字典表 (自己创建的字典表)</span><br><span class="line"> * @param code</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public List&lt;DictModel&gt; queryTableDictItemsByCode(@Param(&quot;table&quot;) String table,@Param(&quot;text&quot;) String text,@Param(&quot;code&quot;) String code);</span><br></pre></td></tr></table></figure>
</li>
<li><p>mapper.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   &lt;!-- 通过字典code获取有效的字典数据项 --&gt;</span><br><span class="line">&lt;select id=&quot;queryEnableDictItemsByCode&quot; parameterType=&quot;String&quot;  resultType=&quot;org.jeecg.common.system.vo.DictModel&quot;&gt;</span><br><span class="line">	   select s.item_value as &quot;value&quot;,s.item_text as &quot;text&quot; from sys_dict_item s</span><br><span class="line">	   where dict_id = (select id from sys_dict where dict_code = #&#123;code&#125;)</span><br><span class="line">	   and s.status = 1</span><br><span class="line">	   order by s.sort_order asc</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!--通过查询指定table的 text code 获取字典--&gt;</span><br><span class="line">&lt;select id=&quot;queryTableDictItemsByCode&quot; parameterType=&quot;String&quot;  resultType=&quot;org.jeecg.common.system.vo.DictModel&quot;&gt;</span><br><span class="line">	   select $&#123;text&#125; as &quot;text&quot;,$&#123;code&#125; as &quot;value&quot; from $&#123;table&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用自定义注解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**出库类型*/</span><br><span class="line">@Excel(name = &quot;出库类型&quot;, width = 15, dicCode = &quot;outWarehouseType&quot;)</span><br><span class="line">   @ApiModelProperty(value = &quot;出库类型&quot;)</span><br><span class="line">   @MyDict(dicCode = &quot;outWarehouseType&quot;)</span><br><span class="line">   private java.lang.String outType;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(value = &quot;/test&quot;, method = RequestMethod.POST)</span><br><span class="line">@ApiOperation(value=&quot;字典翻译测试&quot;, notes=&quot;字典翻译测试&quot;)</span><br><span class="line">public Result&lt;?&gt; importExcel(@RequestParam(name=&quot;pageNo&quot;, defaultValue=&quot;1&quot;) Integer pageNo,</span><br><span class="line">                            @RequestParam(name=&quot;pageSize&quot;, defaultValue=&quot;10&quot;) Integer pageSize) throws JsonProcessingException &#123;</span><br><span class="line">Page&lt;WarehouseOutCertificate&gt; pageTest = warehouseOutCertificateService.page(new Page&lt;WarehouseOutCertificate&gt;(pageNo, pageSize));</span><br><span class="line"></span><br><span class="line">ObjectMapper mapper = new ObjectMapper();</span><br><span class="line">String s = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(pageTest);</span><br><span class="line">log.info(&quot;测试字典翻译:&quot;+s);</span><br><span class="line"></span><br><span class="line">return Result.OK(pageTest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试数据<br><img src="https://cdn.jsdelivr.net/gh/a201-11001001/jsd_blog_staticSource/source/_posts/%E5%BA%8F%E5%88%97%E5%8C%96%E7%BF%BB%E8%AF%91/test.png" alt="图片"></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>方案设计</tag>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程学习-分片下载</title>
    <url>/2024/01/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E5%88%86%E7%89%87%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<h4 id="多线程分片下载"><a href="#多线程分片下载" class="headerlink" title="多线程分片下载"></a>多线程分片下载</h4><blockquote>
<p>实现思路:<br>利用 URLConnection 获取要下载文件的长度、头部等相关信息，并设置响应的头部信息。设置对应的下载线程将要下载的文件进行切片处理，利用 Future + Callable接口 + 线程池 的方式为每一块分片文件单独开辟一个线程完成临时切片文件的读取、写入,并对每个临时切块文件做标识,通过 RandomAccessFile 将多个临时文件做文件合并,最后清理多个分段文件</p>
</blockquote>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 多线程下载</span><br><span class="line"> */</span><br><span class="line">public class DownloadMain &#123;</span><br><span class="line">    // 下载线程数量</span><br><span class="line">    public static int DOWNLOAD_THREAD_NUM = 5;</span><br><span class="line">    // 下载线程池</span><br><span class="line">    private static ExecutorService executor = Executors.newFixedThreadPool(2* DOWNLOAD_THREAD_NUM);</span><br><span class="line">    // 临时文件后缀</span><br><span class="line">    public static String FILE_TEMP_SUFFIX = &quot;.temp&quot;;</span><br><span class="line"></span><br><span class="line">    // 支持的 URL 协议</span><br><span class="line">    private static HashSet&lt;String&gt; PROTOCAL_SET = new HashSet();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 文件存储位置</span><br><span class="line">     */</span><br><span class="line">    private final String SAVEFILEPATH = &quot;/Users/a201/Downloads/&quot;;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        PROTOCAL_SET.add(&quot;thunder://&quot;);</span><br><span class="line">        PROTOCAL_SET.add(&quot;http://&quot;);</span><br><span class="line">        PROTOCAL_SET.add(&quot;https://&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;请输入要下载的链接:&quot;);</span><br><span class="line">        String url = scanner.nextLine();</span><br><span class="line">        long count = PROTOCAL_SET.stream().filter(prefix -&gt; url.startsWith(prefix)).count();</span><br><span class="line">        if (count == 0) &#123;</span><br><span class="line">            LogUtils.info(&quot;不支持的协议类型&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        LogUtils.info(&quot;要下载的链接是:&#123;&#125;&quot;, url);</span><br><span class="line">        new DownloadMain().download(ThunderUtils.toHttpUrl(url));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过 HttpURLConnection 获取 下载文件的大小 / 下载线程数量 对文件进行切片</span><br><span class="line">     *</span><br><span class="line">     * @param url</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public void download(String url) throws Exception &#123;</span><br><span class="line">        String fileName = HttpUtls.getHttpFileName(url);</span><br><span class="line">        long localFileSize = FileUtils.getFileContentLength(fileName);</span><br><span class="line">        // 获取网络文件具体大小</span><br><span class="line">        long httpFileContentLength = HttpUtls.getHttpFileContentLength(url);</span><br><span class="line"></span><br><span class="line">        if (localFileSize &gt;= httpFileContentLength) &#123;</span><br><span class="line">            LogUtils.info(&quot;&#123;&#125;已经下载完毕，无需重新下载&quot;, fileName);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (localFileSize &gt; 0) &#123;</span><br><span class="line">            LogUtils.info(&quot;开始断点续传 &#123;&#125;&quot;, fileName);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            LogUtils.info(&quot;开始下载文件 &#123;&#125;&quot;, fileName);</span><br><span class="line">        &#125;</span><br><span class="line">        LogUtils.info(&quot;开始下载时间 &#123;&#125;&quot;, LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd hh:mm:ss&quot;)));</span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        List&lt;Future&lt;Boolean&gt;&gt; futureList = new ArrayList&lt;&gt;();</span><br><span class="line">        // 任务切分</span><br><span class="line">        splitDownload(url, futureList);</span><br><span class="line"></span><br><span class="line">        // 日志记录</span><br><span class="line">        LogThread logThread = new LogThread(httpFileContentLength);</span><br><span class="line">        Future&lt;Boolean&gt; future = executor.submit(logThread);</span><br><span class="line">        futureList.add(future);</span><br><span class="line"></span><br><span class="line">        // 开始下载</span><br><span class="line">        for (Future&lt;Boolean&gt; booleanFuture : futureList) &#123;</span><br><span class="line">            // get()阻塞线程 确保下载内容完整</span><br><span class="line">            booleanFuture.get();</span><br><span class="line">        &#125;</span><br><span class="line">        LogUtils.info(&quot;文件下载完毕 &#123;&#125;，本次下载耗时：&#123;&#125;&quot;, fileName, (System.currentTimeMillis() - startTime) / 1000 + &quot;s&quot;);</span><br><span class="line">        LogUtils.info(&quot;结束下载时间 &#123;&#125;&quot;, LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd hh:mm:ss&quot;)));</span><br><span class="line"></span><br><span class="line">        // 文件合并</span><br><span class="line">        boolean merge = merge(SAVEFILEPATH+fileName);</span><br><span class="line">        if (merge) &#123;</span><br><span class="line">            // 清理分段文件</span><br><span class="line">            clearTemp(SAVEFILEPATH+fileName);</span><br><span class="line">        &#125;</span><br><span class="line">        LogUtils.info(&quot;本次文件下载结束&quot;);</span><br><span class="line">        System.exit(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 切分下载任务到多个线程</span><br><span class="line">     *</span><br><span class="line">     * @param url</span><br><span class="line">     * @param futureList</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    public void splitDownload(String url, List&lt;Future&lt;Boolean&gt;&gt; futureList) throws IOException &#123;</span><br><span class="line">        long httpFileContentLength = HttpUtls.getHttpFileContentLength(url);</span><br><span class="line">        // 任务切分</span><br><span class="line">        long size = httpFileContentLength / DOWNLOAD_THREAD_NUM;</span><br><span class="line">        // 最后一节的长度</span><br><span class="line">        long lastSize = httpFileContentLength - (httpFileContentLength / DOWNLOAD_THREAD_NUM * (DOWNLOAD_THREAD_NUM - 1));</span><br><span class="line">        for (int i = 0; i &lt; DOWNLOAD_THREAD_NUM; i++) &#123;</span><br><span class="line">            long start = i * size;</span><br><span class="line">            Long downloadWindow = (i == DOWNLOAD_THREAD_NUM - 1) ? lastSize : size;</span><br><span class="line">            Long end = start + downloadWindow;</span><br><span class="line">            if (start != 0) &#123;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 设置 范围请求</span><br><span class="line">            DownloadThread downloadThread = new DownloadThread(url, start, end, i, httpFileContentLength);</span><br><span class="line">            Future&lt;Boolean&gt; future = executor.submit(downloadThread);</span><br><span class="line">            futureList.add(future);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean merge(String fileName) throws IOException &#123;</span><br><span class="line">        LogUtils.info(&quot;开始合并文件 &#123;&#125;&quot;, fileName);</span><br><span class="line">        byte[] buffer = new byte[1024 * 10];</span><br><span class="line">        int len = -1;</span><br><span class="line">        try (RandomAccessFile oSavedFile = new RandomAccessFile(fileName, &quot;rw&quot;)) &#123;</span><br><span class="line">            for (int i = 0; i &lt; DOWNLOAD_THREAD_NUM; i++) &#123;</span><br><span class="line">                try (BufferedInputStream bis = new BufferedInputStream(</span><br><span class="line">                    new FileInputStream(fileName + FILE_TEMP_SUFFIX + i))) &#123;</span><br><span class="line">                    while ((len = bis.read(buffer)) != -1) &#123; // 读到文件末尾则返回-1</span><br><span class="line">                        oSavedFile.write(buffer, 0, len);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            LogUtils.info(&quot;文件合并完毕 &#123;&#125;&quot;, fileName);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean clearTemp(String fileName) &#123;</span><br><span class="line">        LogUtils.info(&quot;开始清理临时文件 &#123;&#125;&#123;&#125;0-&#123;&#125;&quot;, fileName, FILE_TEMP_SUFFIX, (DOWNLOAD_THREAD_NUM - 1));</span><br><span class="line">        for (int i = 0; i &lt; DOWNLOAD_THREAD_NUM; i++) &#123;</span><br><span class="line">            File file = new File(fileName + FILE_TEMP_SUFFIX + i);</span><br><span class="line">            file.delete();</span><br><span class="line">        &#125;</span><br><span class="line">        LogUtils.info(&quot;临时文件清理完毕 &#123;&#125;&#123;&#125;0-&#123;&#125;&quot;, fileName, FILE_TEMP_SUFFIX, (DOWNLOAD_THREAD_NUM - 1));</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="迅雷下载链接转换工具"><a href="#迅雷下载链接转换工具" class="headerlink" title="迅雷下载链接转换工具"></a>迅雷下载链接转换工具</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 迅雷链接转换工具</span><br><span class="line"> * @author woniu</span><br><span class="line"> */</span><br><span class="line">public class ThunderUtils &#123;</span><br><span class="line"></span><br><span class="line">    private static String THUNDER = &quot;thunder://&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断是否是迅雷链接</span><br><span class="line">     *</span><br><span class="line">     * @param url</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static boolean isThunderLink(String url) &#123;</span><br><span class="line">        return url.startsWith(THUNDER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 转换成 HTTP URL</span><br><span class="line">     *</span><br><span class="line">     * @param url</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static String toHttpUrl(String url) &#123;</span><br><span class="line">        if (!isThunderLink(url)) &#123;</span><br><span class="line">            return url;</span><br><span class="line">        &#125;</span><br><span class="line">        LogUtils.info(&quot;当前链接是迅雷链接，开始转换...&quot;);</span><br><span class="line">        url = url.replaceFirst(THUNDER, &quot;&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            // base 64 转换</span><br><span class="line">            url = new String(Base64.getDecoder().decode(url.getBytes()), &quot;UTF-8&quot;);</span><br><span class="line">            // url 解码</span><br><span class="line">            url = URLDecoder.decode(url, &quot;UTF-8&quot;);</span><br><span class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        // 去头去尾</span><br><span class="line">        if (url.startsWith(&quot;AA&quot;)) &#123;</span><br><span class="line">            url = url.substring(2);</span><br><span class="line">        &#125;</span><br><span class="line">        if (url.endsWith(&quot;ZZ&quot;)) &#123;</span><br><span class="line">            url = url.substring(0, url.length() - 2);</span><br><span class="line">        &#125;</span><br><span class="line">        LogUtils.info(&quot;当前链接是迅雷链接，转换结果:&#123;&#125;&quot;, url);</span><br><span class="line">        return url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="文件操作工具类"><a href="#文件操作工具类" class="headerlink" title="文件操作工具类"></a>文件操作工具类</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 文件操作工具类</span><br><span class="line"> */</span><br><span class="line">public class FileUtils &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取文件内容长度</span><br><span class="line">     *</span><br><span class="line">     * @param name</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static long getFileContentLength(String name) &#123;</span><br><span class="line">        File file = new File(name);</span><br><span class="line">        return file.exists() &amp;&amp; file.isFile() ? file.length() : 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="网络请求工具类"><a href="#网络请求工具类" class="headerlink" title="网络请求工具类"></a>网络请求工具类</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 网络请求操作工具类</span><br><span class="line"> * @author woniu</span><br><span class="line"> */</span><br><span class="line">public class HttpUtls &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取 HTTP 链接</span><br><span class="line">     *</span><br><span class="line">     * @param url</span><br><span class="line">     * @return</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    public static HttpURLConnection getHttpUrlConnection(String url) throws IOException &#123;</span><br><span class="line">        URL httpUrl = new URL(url);</span><br><span class="line">        HttpURLConnection httpConnection = (HttpURLConnection)httpUrl.openConnection();</span><br><span class="line">        httpConnection.setRequestProperty(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36&quot;);</span><br><span class="line">        return httpConnection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取 HTTP 链接</span><br><span class="line">     * 设置 RequestProperty 中的请求头 Range: bytes=40-100 设置请求范围</span><br><span class="line">     *</span><br><span class="line">     * @param url</span><br><span class="line">     * @param start</span><br><span class="line">     * @param end</span><br><span class="line">     * @return</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    public static HttpURLConnection getHttpUrlConnection(String url, long start, Long end) throws IOException &#123;</span><br><span class="line">        HttpURLConnection httpUrlConnection = getHttpUrlConnection(url);</span><br><span class="line">        LogUtils.debug(&quot;此线程下载内容区间 &#123;&#125;-&#123;&#125;&quot;, start, end);</span><br><span class="line">        if (end != null) &#123;</span><br><span class="line">            httpUrlConnection.setRequestProperty(&quot;RANGE&quot;, &quot;bytes=&quot; + start + &quot;-&quot; + end);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            httpUrlConnection.setRequestProperty(&quot;RANGE&quot;, &quot;bytes=&quot; + start + &quot;-&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; headerFields = httpUrlConnection.getHeaderFields();</span><br><span class="line">        for (String s : headerFields.keySet()) &#123;</span><br><span class="line">            LogUtils.debug(&quot;此线程相应头&#123;&#125;:&#123;&#125;&quot;, s, headerFields.get(s));</span><br><span class="line">        &#125;</span><br><span class="line">        return httpUrlConnection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取网络文件大小 bytes</span><br><span class="line">     *</span><br><span class="line">     * @param url</span><br><span class="line">     * @return</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    public static long getHttpFileContentLength(String url) throws IOException &#123;</span><br><span class="line">        HttpURLConnection httpUrlConnection = getHttpUrlConnection(url);</span><br><span class="line">        int contentLength = httpUrlConnection.getContentLength();</span><br><span class="line">        httpUrlConnection.disconnect();</span><br><span class="line">        return contentLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取网络文件 Etag</span><br><span class="line">     *</span><br><span class="line">     * @param url</span><br><span class="line">     * @return</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    public static String getHttpFileEtag(String url) throws IOException &#123;</span><br><span class="line">        HttpURLConnection httpUrlConnection = getHttpUrlConnection(url);</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; headerFields = httpUrlConnection.getHeaderFields();</span><br><span class="line">        List&lt;String&gt; eTagList = headerFields.get(&quot;ETag&quot;);</span><br><span class="line">        httpUrlConnection.disconnect();</span><br><span class="line">        return eTagList.get(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取网络文件名</span><br><span class="line">     *</span><br><span class="line">     * @param url</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static String getHttpFileName(String url) &#123;</span><br><span class="line">        int indexOf = url.lastIndexOf(&quot;/&quot;);</span><br><span class="line">        return url.substring(indexOf + 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="多线程日志下载工具类"><a href="#多线程日志下载工具类" class="headerlink" title="多线程日志下载工具类"></a>多线程日志下载工具类</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 多线程下载工具类</span><br><span class="line"> *</span><br><span class="line"> * @Date 2020/7/19 21:26</span><br><span class="line"> */</span><br><span class="line">public class DownloadThread implements Callable&lt;Boolean&gt; &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 每次读取的数据块大小</span><br><span class="line">     */</span><br><span class="line">    private static int BYTE_SIZE = 1024 * 100;</span><br><span class="line">    /**</span><br><span class="line">     * 下载链接</span><br><span class="line">     */</span><br><span class="line">    private String url;</span><br><span class="line">    /**</span><br><span class="line">     * 下载开始位置</span><br><span class="line">     */</span><br><span class="line">    private long startPos;</span><br><span class="line">    /**</span><br><span class="line">     * 要下载的文件区块大小</span><br><span class="line">     */</span><br><span class="line">    private Long endPos;</span><br><span class="line">    /**</span><br><span class="line">     * 标识多线程下载切分的第几部分</span><br><span class="line">     */</span><br><span class="line">    private Integer part;</span><br><span class="line">    /**</span><br><span class="line">     * 文件总大小</span><br><span class="line">     */</span><br><span class="line">    private Long contentLenth;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 文件存储位置</span><br><span class="line">     */</span><br><span class="line">    private final String SAVEFILEPATH = &quot;/Users/a201/Downloads/&quot;;</span><br><span class="line">    public DownloadThread(String url, long startPos, Long endPos, Integer part, Long contentLenth) &#123;</span><br><span class="line">        this.url = url;</span><br><span class="line">        this.startPos = startPos;</span><br><span class="line">        this.endPos = endPos;</span><br><span class="line">        this.part = part;</span><br><span class="line">        this.contentLenth = contentLenth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Boolean call() throws Exception &#123;</span><br><span class="line">        if (url == null || url.trim() == &quot;&quot;) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;下载路径不正确&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 文件名</span><br><span class="line">        String httpFileName =  SAVEFILEPATH + HttpUtls.getHttpFileName(url);</span><br><span class="line">        // 临时分片文件名</span><br><span class="line">        if (part != null) &#123;</span><br><span class="line">            httpFileName = httpFileName + DownloadMain.FILE_TEMP_SUFFIX + part;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 本地文件大小</span><br><span class="line">        Long localFileContentLength = FileUtils.getFileContentLength(httpFileName);</span><br><span class="line">        LogThread.LOCAL_FINISH_SIZE.addAndGet(localFileContentLength);</span><br><span class="line"></span><br><span class="line">        if (localFileContentLength &gt;= endPos - startPos) &#123;</span><br><span class="line">            LogUtils.info(&quot;&#123;&#125; 已经下载完毕，无需重复下载&quot;, httpFileName);</span><br><span class="line">            LogThread.DOWNLOAD_FINISH_THREAD.addAndGet(1);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (endPos.equals(contentLenth)) &#123;</span><br><span class="line">            endPos = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 设置请求范围</span><br><span class="line">        HttpURLConnection httpUrlConnection = HttpUtls.getHttpUrlConnection(url, startPos + localFileContentLength, endPos);</span><br><span class="line">        // 获得输入流</span><br><span class="line">        try (InputStream input = httpUrlConnection.getInputStream();</span><br><span class="line">             BufferedInputStream bis = new BufferedInputStream(input);</span><br><span class="line">             RandomAccessFile oSavedFile = new RandomAccessFile(httpFileName, &quot;rw&quot;)) &#123;</span><br><span class="line">                oSavedFile.seek(localFileContentLength);</span><br><span class="line">                byte[] buffer = new byte[BYTE_SIZE];</span><br><span class="line">                int len = -1;</span><br><span class="line">                // 读到文件末尾则返回-1</span><br><span class="line">                while ((len = bis.read(buffer)) != -1) &#123;</span><br><span class="line">                    oSavedFile.write(buffer, 0, len);</span><br><span class="line">                    LogThread.DOWNLOAD_SIZE.addAndGet(len);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            LogUtils.error(&quot;ERROR! 要下载的文件路径不存在 &#123;&#125; &quot;, url);</span><br><span class="line">            return false;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            LogUtils.error(&quot;下载出现异常&quot;);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return false;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            httpUrlConnection.disconnect();</span><br><span class="line">            LogThread.DOWNLOAD_FINISH_THREAD.addAndGet(1);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="线程日志工具-LogUtils"><a href="#线程日志工具-LogUtils" class="headerlink" title="线程日志工具 LogUtils"></a>线程日志工具 LogUtils</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author woniu</span><br><span class="line"> */</span><br><span class="line">public class LogUtils &#123;</span><br><span class="line"></span><br><span class="line">    public static boolean DEBUG = false;</span><br><span class="line"></span><br><span class="line">    static DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd hh:mm:ss&quot;);</span><br><span class="line"></span><br><span class="line">    public static void info(String msg, Object... arg) &#123;</span><br><span class="line">        print(msg, &quot; -INFO- &quot;, arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void error(String msg, Object... arg) &#123;</span><br><span class="line">        print(msg, &quot; -ERROR-&quot;, arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void debug(String msg, Object... arg) &#123;</span><br><span class="line">        if (DEBUG) &#123; print(msg, &quot; -DEBUG-&quot;, arg); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void print(String msg, String level, Object... arg) &#123;</span><br><span class="line">        if (arg != null &amp;&amp; arg.length &gt; 0) &#123;</span><br><span class="line">            msg = String.format(msg.replace(&quot;&#123;&#125;&quot;, &quot;%s&quot;), arg);</span><br><span class="line">        &#125;</span><br><span class="line">        // 获取当前运行线程名字</span><br><span class="line">        String thread = Thread.currentThread().getName();</span><br><span class="line">        System.out.println(LocalDateTime.now().format(dateTimeFormatter) + &quot; &quot; + thread + level + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="多线程下载日志记录"><a href="#多线程下载日志记录" class="headerlink" title="多线程下载日志记录"></a>多线程下载日志记录</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 多线程下载日志记录</span><br><span class="line"> */</span><br><span class="line">public class LogThread implements Callable&lt;Boolean&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public static AtomicLong LOCAL_FINISH_SIZE = new AtomicLong();</span><br><span class="line">    public static AtomicLong DOWNLOAD_SIZE = new AtomicLong();</span><br><span class="line">    public static AtomicLong DOWNLOAD_FINISH_THREAD = new AtomicLong();</span><br><span class="line">    private long httpFileContentLength;</span><br><span class="line"></span><br><span class="line">    public LogThread(long httpFileContentLength) &#123;</span><br><span class="line">        this.httpFileContentLength = httpFileContentLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Boolean call() throws Exception &#123;</span><br><span class="line">        int[] downSizeArr = new int[5];</span><br><span class="line">        int i = 0;</span><br><span class="line">        double size = 0;</span><br><span class="line">        double mb = 1024d * 1024d;</span><br><span class="line">        // 文件总大小</span><br><span class="line">        String httpFileSize = String.format(&quot;%.2f&quot;, httpFileContentLength / mb);</span><br><span class="line">        while (DOWNLOAD_FINISH_THREAD.get() != DownloadMain.DOWNLOAD_THREAD_NUM) &#123;</span><br><span class="line">            double downloadSize = DOWNLOAD_SIZE.get();</span><br><span class="line">            downSizeArr[++i % 5] = Double.valueOf(downloadSize - size).intValue();</span><br><span class="line">            size = downloadSize;</span><br><span class="line"></span><br><span class="line">            // 每秒速度</span><br><span class="line">            double fiveSecDownloadSize = Arrays.stream(downSizeArr).sum();</span><br><span class="line">            int speed = (int)((fiveSecDownloadSize / 1024d) / (i &lt; 5d ? i : 5d));</span><br><span class="line"></span><br><span class="line">            // 剩余时间</span><br><span class="line">            double surplusSize = httpFileContentLength - downloadSize - LOCAL_FINISH_SIZE.get();</span><br><span class="line">            String surplusTime = String.format(&quot;%.1f&quot;, surplusSize / 1024d / speed);</span><br><span class="line">            if (surplusTime.equals(&quot;Infinity&quot;)) &#123;</span><br><span class="line">                surplusTime = &quot;-&quot;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 已下大小</span><br><span class="line">            String currentFileSize = String.format(&quot;%.2f&quot;, downloadSize / mb + LOCAL_FINISH_SIZE.get() / mb);</span><br><span class="line">            String speedLog = String.format(&quot;&gt; 已下载 %smb/%smb,速度 %skb/s,剩余时间 %ss&quot;, currentFileSize, httpFileSize, speed, surplusTime);</span><br><span class="line">            System.out.print(&quot;\r&quot;);</span><br><span class="line">            System.out.print(speedLog);</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h5><ul>
<li><p>日志记录<br><img src="https://cdn.jsdelivr.net/gh/a201-11001001/jsd_blog_staticSource@1.0.4/source/_posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E5%88%86%E7%89%87%E4%B8%8B%E8%BD%BD/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%86%E7%89%87%E4%B8%8B%E8%BD%BD%E6%97%A5%E5%BF%97.png" alt="下载日志记录"></p>
</li>
<li><p>临时文件分片<br><img src="https://cdn.jsdelivr.net/gh/a201-11001001/jsd_blog_staticSource@1.0.4/source/_posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E5%88%86%E7%89%87%E4%B8%8B%E8%BD%BD/%E5%88%86%E7%89%87%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6.png" alt="临时文件分片"></p>
</li>
<li><p>临时文件合并<br><img src="https://cdn.jsdelivr.net/gh/a201-11001001/jsd_blog_staticSource@1.0.4/source/_posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E5%88%86%E7%89%87%E4%B8%8B%E8%BD%BD/%E6%96%87%E4%BB%B6%E5%90%88%E5%B9%B6.png" alt="文件合并"></p>
</li>
</ul>
<h5 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h5><p>[JAVA Future类详解及Thread线程是如何运行Future类的] <a href="https://blog.csdn.net/m0_37798046/article/details/130368908">https://blog.csdn.net/m0_37798046/article/details/130368908</a><br>[Java的RandomAccess] <a href="https://blog.51cto.com/u_92655/6529987">https://blog.51cto.com/u_92655/6529987</a><br>[JAVA的RandomAccessFile] <a href="https://www.jianshu.com/p/c58a6adc2ba5">https://www.jianshu.com/p/c58a6adc2ba5</a><br>[【并发编程】Java5 - Future，基本使用] <a href="https://blog.csdn.net/qq_48008521/article/details/129828902">https://blog.csdn.net/qq_48008521/article/details/129828902</a><br>[彻底搞懂线程池-Executors] <a href="https://blog.csdn.net/lsqingfeng/article/details/124165312">https://blog.csdn.net/lsqingfeng/article/details/124165312</a></p>
]]></content>
      <tags>
        <tag>多线程学习</tag>
      </tags>
  </entry>
</search>
